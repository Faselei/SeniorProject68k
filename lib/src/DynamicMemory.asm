;===============================================================================
;DynamicMemory.asm
;===============================================================================
;C style memory allocation.
;
;This file is ment to be used with both asm and C files, so C function calls
;are used
;
;void initHeap(void);
;void* malloc(size_t size);
;void* calloc(size_t items, size_t size);
;void free(void* ptr);
;void* realloc(void* ptr, size_t size);
;
;These functions are defined as a local scope only
;int 	brk(void* addr);
;void*	sbrk(size_t increment);
;
;
;
;On success, brk() returns zero.  On error, -1 is returned, and
;      errno is set to ENOMEM.
;
;      On success, sbrk() returns the previous program break.  (If the
;      break was increased, then this value is a pointer to the start of
;      the newly allocated memory).  On error, (void *) -1 is returned,
;      and errno is set to ENOMEM.
;-------------------------------------------------------------------------------

	include "errno.inc"

;ERROR numbers
ERROR_NONE equ NONE
ERROR_ENOMEM equ OUT_OF_MEMORY

;Memory size
HEAP_SIZE_TOTAL equ $5fff

;malloc heap access constants
HEAP_PREV equ -8
HEAP_FREE equ -6
HEAP_SIZE equ -4
HEAP_NEXT equ -2

;malloc struct, due to only having 8 bytes using addq,
;we need to do some pointer hacks to keep things in size.
;All 32-bit pointers are chopped to 16-bit, as the upper 16 never change
;
;example pointer
;-8 = prev
;-7 = prev
;-6 = free
;-5 = free
;-4 = size
;-3 = size
;-2 = next
;-1 = next
;
;all memory access should be even, as reading odd addresses at not
;byte level causes exeptions on the 68k

;here are the function calls generated by vbcc and myself.
;	bsr	initHeap
;
;	pea	size
;	bsr	_malloc
;
;	pea	size
;	pea	items
;	bsr	_calloc
;
;	pea	ptr
;	bsr	_free
;
;	pea	size
;	pea	ptr
;	bsr	_realloc

;///////////////////////////////////////////////////////////////////////////////
	section	"BSS",bss

programBreak	ds.l	1
globalBase	ds.l	1
;///////////////////////////////////////////////////////////////////////////////
	section	"HEAP",bss

heap	ds.b	HEAP_SIZE_TOTAL
;///////////////////////////////////////////////////////////////////////////////
	section	"DATA",data
;///////////////////////////////////////////////////////////////////////////////
	section	"CODE",code

;---------------------------------------
;brk
;
;sets the program break to a address
;
;	pea	address
;	bsr	brk
;---------------------------------------
brk:	link	a5,#0
	move.l	(8,a5),d0	;access params (address)
	cmpi.l	#heap,d0	;is this address before the start of the heap?
	blt	.error 		;yes: flag error and return -1
	cmpi.l	#heap+HEAP_SIZE_TOTAL,d0	;no: is this past the heap?
	bgt	.error 		;yes: flag error and return -1
    	move.l	d0,programBreak	;no:its in range of heap, mark new data
    	moveq	#0,d0
    	bra	.exit
.error:	move.b	#ERROR_ENOMEM,_errno
	move.l	#-1,d0
.exit:	unlk	a5
	move.l	(sp),(4,sp)	;deallocate parameters
	lea	(4,sp),sp
	rts

;---------------------------------------
;sbrk
;
;increments the program break by
;a set amount.
;
;	pea 	size
;	bsr	sbrk
;---------------------------------------
sbrk:	link	a5,#0
	move.l	(8,a5),d0	;access params (address)
	add.l 	programBreak,d0	;do the addition to find final programBreak
	cmpi.l 	#heap,d0	;is this address before the start of the heap?
	blt	.error 		;yes: flag error and return -1
	cmpi.l	#heap+HEAP_SIZE_TOTAL,d0	;no: is this past the heap?
	bgt	.error 		;yes: flag error and return -1
	move.l 	d0,programBreak	;no:its in range of heap, mark new data
	bra 	.exit
.error:	move.b 	#ERROR_ENOMEM,_errno
	move.l 	#-1,d0
.exit:	unlk	a5
	move.l	(sp),(4,sp)	;deallocate parameters
	lea	(4,sp),sp
	rts

;---------------------------------------
;findFreeBlock
;
;goes through the whole heap allocated
;space looking for a free block that is
;big enough.
;either return the pointer to the free
;or null (0). This also assums that then
;parent method has already checked for 0's
;
;	pea 	size
;	bsr	findFreeBlock
;---------------------------------------
;d0 = scratch
;d1 = 2nd scratch / new block of memory
;a0 = linked list pointer

findFreeBlock:
	link	a5,#0
	move.l	(8,a5),d0	;access params (size)

	move.l	globalBase,a0
.loop:	tst.w	(HEAP_FREE,a0)	;is this block free?
	bne 	.notUsable	;no: skip to the next block
	cmp.w	(HEAP_SIZE,a0),d0	;yes: is this block big enough?
	bhi	.notUsable		;no: continue

;we can try to break blocks smaller here
	addq.w	#8,d0
	cmp.w	(HEAP_SIZE,a0),d0	;is this block big enough to break down?
	bhi	.cantBreakDown		;no: continue

;yes: time to do some memory hacks
	move.l	a0,a1	;clone the pointer
	move.w	(HEAP_SIZE,a0),d1	;total heap size
	move.l	(8,a5),d0
	move.w	d0,(HEAP_SIZE,a0)
	subq.w	#8,d1	;subtract memory for metts data
	sub.w	d0,d1	;subtract memory needed for the findFreeBlock request

;d1 = new amount of memory that this new block will hold
	tst.w	d1	;is the amount of free memory 0?
	beq	.cantBreakDown	;yes: then don't try it, as its a wast of memory

;no: make the new pointer and populate metta data
	addq.w	#8,a1	;advance pointer by metta data bytes
	add.w	d0,a1	;advance pointer by requested bytes

;start inserting the new list into the heap
	move.w	(HEAP_NEXT,a0),d0	;forward HEAP_NEXT to the new node
	move.w	d0,(HEAP_NEXT,a1)

	move.w	a1,(HEAP_NEXT,a0)

	move.w	a0,(HEAP_PREV,a1)

	tst.w	(HEAP_NEXT,a1)		;is there a next element?
	beq	.noNextElement		;no: then skip
	move.w	a0,-(sp)		;we need to save a0, found block
	move.w	(HEAP_NEXT,a1),a0	;get the next element
	move.w	a1,(HEAP_PREV,a0)	;set the next.prev to the new block
	move.w	(sp)+,a0		;restore a0
.noNextElement:

	move.w	#0,(HEAP_FREE,a1)	;mark this new block is free
	move.w	d1,(HEAP_SIZE,a1)	;save the size

.cantBreakDown:
	move.w	#-1,(HEAP_FREE,a0)	;yes: mark it as not free and return
	move.l	a0,d0
	bra	.exit

.notUsable:
	tst.w	(HEAP_NEXT,a0)	;is there a next element?
	beq 	.fail		;no: no free space left to look through
	move.w	(HEAP_NEXT,a0),a0	;yes: set as next and loop
	bra	.loop

.fail:	moveq	#0,d0
.exit:	unlk	a5
	move.l	(sp),(4,sp)	;deallocate parameters
	lea	(4,sp),sp
	rts

;---------------------------------------
;advances the program break and returns
;the new area of memory allocated
;
;	pea 	size
;	pea 	last
;	bsr 	requestSpace
;---------------------------------------
;a0 = newBlock
;a1 = last
requestSpace:
	link	a5,#0

;get the current program break
	pea 	0
	bsr 	sbrk
	move.l 	d0,a0

;get the prev element for later
	move.l 	(8,a5),a1

;add the metta size to the request size and allocate space
	move.l	(12,a5),d0	;access params (size)
	addq.l 	#8,d0
	move.l 	d0,-(sp)
	bsr 	sbrk
	cmpi.l 	#-1,d0		;did that fail?
	beq	.fail 		;yes: return null (0)

;adjust pointer to where the data is for real
	addq.w	#8,a0

;check if this block needs to be appended to a previous element
	cmpa.l 	#0,a1		;is there a prev (last) element?
	beq	.noPrev		;no: skip this
	move.w 	a0,(-2,a1)
.noPrev:

	move.w	a1,(HEAP_PREV,a0)	;last
	move.w	#-1,(HEAP_FREE,a0)	;free
	move.l 	(12,a5),d0
	move.w	d0,(HEAP_SIZE,a0)	;size
	move.w	#0,(HEAP_NEXT,a0)	;next
	move.l	a0,d0
	bra 	.exit


.fail:	moveq	#0,d0
.exit:	unlk	a5
	move.l	(sp),(8,sp)	;deallocate parameters
	lea	(8,sp),sp
	rts

;---------------------------------------
;_malloc
;
;Allocates memory on the heap, returns
;a pointer to memory or null (0)
;
;	pea	size
;	bsr	_malloc
;	addq.w 	#4,sp
;---------------------------------------
	public	_malloc
_malloc:
	link	a5,#0

;allocating 0 bytes or -# bytes?
	tst.l	(8,a5)
	beq	.error
	blt	.error

;allocating an odd number of bytes?
	move.l	(8,a5),d0
	btst	#0,d0
	beq	.even
	addq.l	#1,(8,a5)	;make even to avoid address errors
.even:

;1st time calling _malloc?
	tst.l	globalBase
	bne	.notFirstTime

;yes: pass null as last, size as size, and call requestSpace
	move.l	(8,a5),d0
	move.l	d0,-(sp)
	pea	0
	bsr	requestSpace
	tst.l	d0		;did that work?
	beq	.error		;no: return null (0)
	move.l	d0,globalBase	;yes: set this as the start of the heap
	bra	.exit		;and exit
.notFirstTime:

;no: find a free block of memory first in the heap before allocating more memory
	move.l	(8,a5),-(sp)	;how many bytes?
	bsr	findFreeBlock	;find it
	tst.l	d0		;did we find any?
	bne	.exit		;yes: we can exit
	move.l	(8,a5),-(sp)	;no: we then allocate space

;find the end of the linked list
	move.l	globalBase,a0	;start at the beginning
.loop:	tst.w	(HEAP_NEXT,a0)	;is this->next == null?
	beq	.foundEnd	;yes: continue
	move.w	(HEAP_NEXT,a0),a0	;no: move onto the next element
	bra	.loop		;and go back to the beginning
.foundEnd:
	move.l	a0,-(sp)	;push the end of the linked list
	bsr	requestSpace	;and allocate more memory on the heap

	tst.l	d0		;did that work?
	beq	.error		;no: return null (0)
	bra	.exit		;and exit
.error:	moveq	#0,d0			;if we had a problem, return null (0)
	move.b 	#ERROR_ENOMEM,_errno	;and set _errno
.exit:	unlk	a5
	rts

;---------------------------------------
;_free
;
;free a pices of Memory
;
;	pea	ptr
;	bsr	_free
;	addq.w 	#4,sp
;---------------------------------------
;a0 = this

	public	_free
_free:	link	a5,#0
	move.l	a2,-(sp)	;we use a2
	move.l	(8,a5),a0	;get params
	move.l	a0,a1		;get the full pointers populated
	move.l	a1,a2

;free this block of memory
	move.w	#0,(HEAP_FREE,a0)

	move.w	(HEAP_NEXT,a0),a1
	cmp.w	#0,a1
	beq	.nextNotFree	;no Next element
	tst.w	(HEAP_FREE,a1)	;is the next block free?
	bne 	.nextNotFree	;no: skip, see of prev is free
	move.w	(HEAP_NEXT,a1),a2	;yes: concatinate the 2 blocks into 1
	tst.w	(a2)		;unless there is no next element
	beq 	.nextNotFree

	move.w	a0,(HEAP_PREV,a2)	;set the next.next block to this block
	move.w	a2,(HEAP_NEXT,a0)	;set this block to next.next
	move.w	(HEAP_SIZE,a1),d0	;combine the size
	add.w	d0,(HEAP_SIZE,a0)
	addq.w	#8,(HEAP_SIZE,a0)	;don't forget metta size

.nextNotFree:
	move.w	(HEAP_PREV,a0),a1
	cmp.w	#0,a1
	beq	.prevNotFree	;no previous element
	tst.w	(HEAP_FREE,a1)	;is the previous block free?
	bne	.prevNotFree	;no: nothing else to do so exit
	move.w	(HEAP_PREV,a1),a2
	tst.w	(a2)		;unless there is no prev block
	beq 	.prevNotFree

	move.w	(HEAP_NEXT,a0),a2

	move.w	a1,(HEAP_PREV,a2)	;set the prev.next block to this block
	move.w	a2,(HEAP_NEXT,a1)	;set this block to next.next
	move.w	(HEAP_SIZE,a0),d0	;combine the size
	add.w	d0,(HEAP_SIZE,a1)
	addq.w	#8,(HEAP_SIZE,a1)	;don't forget metta size

.prevNotFree:
	move.l	(sp)+,a2	;restore a2
	unlk	a5
	rts

;---------------------------------------
;initHeap
;
;Sets up the heap, should be called once
;
;	bsr	initHeap
;---------------------------------------
	public	initHeap
initHeap:
	move.l	#0,globalBase
	pea 	heap
	bsr 	brk
	rts

;---------------------------------------
;_calloc
;
;Description:
;allocates n units of size size,
;all set to 0.
;
;Calling Convention:
;
;void*	calloc(uint8_t n, uint16_t size);
;
;	pea	size
;	pea	n
;	bsr	_calloc
;	addq.w	#8,sp
;
;RETUNRS:
;a pointer to 0 init memory or null.
;---------------------------------------
	public	_calloc
_calloc:
	link	a5,#0
	move.l	d2,-(sp)

	move.l	(8,a5),d0	;n
	move.l	(12,a5),d1	;size
	mulu	d0,d1		;d1 = final size
	tst.l	d1		;final size = 0?
	bne	.validSize	;no: continue
	moveq	#0,d0		;yes: return null
	bra	.exit
.validSize:
	move.l	d1,-(sp)	;take our total size
	bsr	_malloc		;and do a regulat malloc call
	move.l	(sp)+,d1	;restore the size back to d1
	tst.l	d0		;did that work?
	beq	.exit		;no: return null
	move.l	d0,d2		;yes: save the pointer for now
	move.l	d0,-(sp)	;target
	pea	0		;value
	move.l	d1,-(sp)	;size
	bsr	_memset		;preform clearing
	add.w	#12,sp		;clean op our mess
	move.l	d2,d0		;restore pointer to memory
.exit:	move.l	(sp)+,d2
	unlk	a5
	rts

;---------------------------------------
;_realloc
;
;used to dynamically change the memory
;allocation of a previously allocated
;memory.
;
;Calling Convention
;void*   realloc(void* ptr, uint16_t size);
;
;	move.l	#size,-(sp)
;	pea	ptr
;	bsr	_realloc
;	addq	#8,sp
;
;---------------------------------------
;d0 =
;d1 =
;d2 = pointer to new block
;d3 = pointer to original block
;d4 = size
	public	_realloc
_realloc:
	link	a5,#0
	move.l	d2,-(sp)
	move.l	d3,-(sp)
	move.l	d4,-(sp)

	move.l	(8,a5),d3	;pointer
	move.l	(12,a5),d4	;size

;allocate new block of memory
	move.l	d4,-(sp)	;size
	bsr	_malloc		;allocate it
	move.l	d0,d2		;save the result
	tst.l	d2		;any problems?
	beq	.exit		;yes: return null

;copy stuff over
	move.l	d4,-(sp)	;size
	move.l	d3,-(sp)	;src
	move.l	d2,-(sp)	;dest
	bsr	_memcpy
	add.w	#12,sp

;clean up our mess
.exit:	move.l	d3,-(sp)	;free the original pointer
	bsr	_free
	addq.w	#4,sp
	move.l	d2,d0		;store result
	move.l	(sp)+,d4
	move.l	(sp)+,d3
	move.l	(sp)+,d2
	unlk	a5
	rts
