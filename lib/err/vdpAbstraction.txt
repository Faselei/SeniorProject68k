F00:0001       ;===============================================================================
F00:0002       ;vdpAbstraction.asm
F00:0003       ;===============================================================================
F00:0004       ;abstraction layer for the VDP
F00:0005       ;-------------------------------------------------------------------------------
F00:0006       
F00:0007       	include "vdpAbstraction.inc"
F01:0001       ;===============================================================================
F01:0002       ;vdpAbstraction.inc
F01:0003       ;===============================================================================
F01:0004       ;defines vdp ports and constants for other assembly files
F01:0005       ;-------------------------------------------------------------------------------
F01:0006       
F01:0007       ;VDP registers
F01:0008       VDP_DATA equ $00C00000
F01:0009       VDP_CTRL equ $00C00004
F01:0010       VDP_HVCOUNTER equ $00C00008
F01:0011       
F01:0012       ;VDP constants
F01:0013       VDP_REGION_NTSC equ 1
F01:0014       VDP_REGION_PAL equ 2
F01:0015       
F01:0016       ;User DMA constants
F01:0017       DMA_TYPE_MAIN equ 0
F01:0018       DMA_TYPE_FILL equ 1
F01:0019       DMA_TYPE_COPY equ 2
F01:0020       
F01:0021       ;VDP data sizes in bytes
F01:0022       VRAM_SIZE    equ 65536
F01:0023       CRAM_SIZE    equ 128
F01:0024       VSRAM_SIZE   equ 80
F01:0025       
F01:0026       ;VDP command constants
F01:0027       VRAM_WRITE_CMD equ $40000000
F01:0028       CRAM_WRITE_CMD equ $C0000000
F01:0029       VSRAM_WRITE_CMD equ $40000010
F01:0030       VRAM_READ_CMD equ $00000000
F01:0031       CRAM_READ_CMD equ $00000040
F01:0032       VSRAM_READ_CMD equ $00000020
F01:0033       VRAM_DMA_CMD equ $40000080
F01:0034       CRAM_DMA_CMD equ $C0000080
F01:0035       VSRAM_DMA_CMD equ $40000090
F01:0036       ;///////////////////////////////////////////////////////////////////////////////
F01:0037       
F00:0008       	include "errno.inc"
F02:0001       ;===============================================================================
F02:0002       ;errno.inc
F02:0003       ;===============================================================================
F02:0004       ;Defines the error codes for things supporting it, should be the same as in
F02:0005       ;errno.h
F02:0006       ;-------------------------------------------------------------------------------
F02:0007       
F02:0008       NONE equ 0
F02:0009       FILE_NOT_FOUND equ 1
F02:0010       DOES_NOT_EXIST equ 2
F02:0011       BAD_ADDRESS equ 3
F02:0012       IO_ERROR equ 4
F02:0013       DEADLOCK equ 5
F02:0014       TOO_LONG equ 6
F02:0015       OUT_OF_MEMORY equ 7
F02:0016       OUT_OF_BOUNDS equ 8
F02:0017       UNKNOWN_INPUT equ 9
F02:0018       
F02:0019       ;///////////////////////////////////////////////////////////////////////////////
F02:0020       	section	"BSS",bss
F02:0021       
F02:0022       ;	public	_errno
F02:0023       ;_errno	ds.l	1
F02:0024       
F02:0025       ;///////////////////////////////////////////////////////////////////////////////
F02:0026       
F02:0027       
F00:0009       
F00:0010       ;alloc struct valuse, might want to move them to vdpAbstraction.inc
F00:0011       VRAM_ALLOC_FREE equ 0
F00:0012       VRAM_ALLOC_VRAM equ 2
F00:0013       VRAM_ALLOC_NUM equ 4
F00:0014       VRAM_ALLOC_NEXT equ 6
F00:0015       
F00:0016       VRAM_MAX_NUMTILES equ 2048
F00:0017       
F00:0018       ;///////////////////////////////////////////////////////////////////////////////
F00:0019       	section	"BSS",bss
F00:0020       
F00:0021       ;vdp shadow registers
F00:0022       	public	shadowVdp_address
F00:0023       shadowVdp_address:
F00:0024       shadowVdp_ModeReg1 ds.b 1
F00:0025       shadowVdp_ModeReg2 ds.b 1
F00:0026       shadowVdp_PlaneA ds.b 1
F00:0027       shadowVdp_Window ds.b 1
F00:0028       shadowVdp_PlaneB ds.b 1
F00:0029       shadowVdp_Sprite ds.b 1
F00:0030       	ds.b 1
F00:0031       shadowVdp_BGColor ds.b 1
F00:0032       	ds.b 1
F00:0033       	ds.b 1
F00:0034       shadowVdp_HRate ds.b 1
F00:0035       shadowVdp_ModeReg3 ds.b 1
F00:0036       shadowVdp_ModeReg4 ds.b 1
F00:0037       shadowVdp_HScroll ds.b 1
F00:0038       	ds.b 1
F00:0039       shadowVdp_Incr ds.b 1
F00:0040       shadowVdp_Size ds.b 1
F00:0041       shadowVdp_WinX ds.b 1
F00:0042       shadowVdp_WinY ds.b 1
F00:0043       
F00:0044       shadowVdp_DMA_L_Low	ds.b	1
F00:0045       shadowVdp_DMA_L_High	ds.b	1
F00:0046       shadowVdp_DMA_S_Low	ds.b	1
F00:0047       shadowVdp_DMA_S_Mid	ds.b	1
F00:0048       shadowVdp_DMA_S_High	ds.b	1
F00:0049       
F00:0050       ;commit DMA flags
F00:0051       vdpCommitColorBufferFlag	ds.b	1
F00:0052       vdpCommitVSRAMBufferFlag	ds.b	1
F00:0053       vdpCommitSpriteBufferFlag	ds.b	1
F00:0054       	public	vdpCommitColorBufferFlag
F00:0055       	public	vdpCommitVSRAMBufferFlag
F00:0056       	public	vdpCommitSpriteBufferFlag
F00:0057       	even
F00:0058       
F00:0059       ;vram allocation start
F00:0060       allocVramStart	ds.l	1
F00:0061       allocVramEnd	ds.l	1
F00:0062       allocVramCurrent ds.w	1
F00:0063       
F00:0064       ;horizontal scroll word
F00:0065       _hScroll ds.w	1
F00:0066       	public	_hScroll
F00:0067       
F00:0068       ;DMA buffers
F00:0069       _colorBuffer ds.b CRAM_SIZE
F00:0070       _VSRamBuffer ds.b VSRAM_SIZE
F00:0071       
F00:0072       	public	_colorBuffer
F00:0073       	public	_VSRamBuffer
F00:0074       
F00:0075       ;///////////////////////////////////////////////////////////////////////////////
F00:0076       	section	"DATA",data
F00:0077       vdpOptionsTable:
F00:0078       	dc.l	shadowVdp_ModeReg1
               S02:00000000:  00 00 00 00 [R]
F00:0079       	dc.l	shadowVdp_ModeReg1
               S02:00000004:  00 00 00 00 [R]
F00:0080       	dc.l	shadowVdp_ModeReg2
               S02:00000008:  00 00 00 01 [R]
F00:0081       	dc.l	shadowVdp_ModeReg2
               S02:0000000C:  00 00 00 01 [R]
F00:0082       	dc.l	shadowVdp_ModeReg2
               S02:00000010:  00 00 00 01 [R]
F00:0083       	dc.l	shadowVdp_ModeReg3
               S02:00000014:  00 00 00 0B [R]
F00:0084       	dc.l	shadowVdp_ModeReg4
               S02:00000018:  00 00 00 0C [R]
F00:0085       
F00:0086       vdpOptionsBits:
F00:0087       	dc.b	$10	;H interrupt
               S02:0000001C:  10
F00:0088       	dc.b	$02	;HV counter
               S02:0000001D:  02
F00:0089       	dc.b	$40	;display
               S02:0000001E:  40
F00:0090       	dc.b	$20	;V interrupt
               S02:0000001F:  20
F00:0091       	dc.b	$10	;DMA
               S02:00000020:  10
F00:0092       	dc.b	$04	;ext interrupt
               S02:00000021:  04
F00:0093       	dc.b	$04	;shadows
               S02:00000022:  04
F00:0094       	even
F00:0095       
F00:0096       ;init values for vdp
F00:0097       InitVDPValues:
F00:0098       	dc.b	$04,$14,$30,$2C,$07,$5F,$00,$00
               S02:00000024:  04
               S02:00000025:  14
               S02:00000026:  30
               S02:00000027:  2C
               S02:00000028:  07
               S02:00000029:  5F
               S02:0000002A:  00
               S02:0000002B:  00
F00:0099       	dc.b	$00,$00,$FF,$00,$00,$2E,$00,$01
               S02:0000002C:  00
               S02:0000002D:  00
               S02:0000002E:  FF
               S02:0000002F:  00
               S02:00000030:  00
               S02:00000031:  2E
               S02:00000032:  00
               S02:00000033:  01
F00:0100       	dc.b	$11,$00,$02,$00,$00,$00,$00,$80
               S02:00000034:  11
               S02:00000035:  00
               S02:00000036:  02
               S02:00000037:  00
               S02:00000038:  00
               S02:00000039:  00
               S02:0000003A:  00
               S02:0000003B:  80
F00:0101       	even
F00:0102       
F00:0103       ;	dc.w	$8004,$8114,$8230,$832C,$8407,$855F,$8600,$8700
F00:0104       ;	dc.w	$8800,$8900,$8AFF,$8B00,$8C00,$8D2E,$8E00,$8F01
F00:0105       ;	dc.w	$9022,$9100,$9200,$9300,$9400,$9500,$9600,$9780
F00:0106       
F00:0107       InitVDPColorData:
F00:0108       	dc.w	$0A42,$0222,$0444,$0666,$0888,$0AAA,$0CCC,$0EEE	;white
               S02:0000003C:  0A 42
               S02:0000003E:  02 22
               S02:00000040:  04 44
               S02:00000042:  06 66
               S02:00000044:  08 88
               S02:00000046:  0A AA
               S02:00000048:  0C CC
               S02:0000004A:  0E EE
F00:0109       	dc.w	$0000,$0002,$0004,$0006,$0008,$000A,$000C,$000E	;red
               S02:0000004C:  00 00
               S02:0000004E:  00 02
               S02:00000050:  00 04
               S02:00000052:  00 06
               S02:00000054:  00 08
               S02:00000056:  00 0A
               S02:00000058:  00 0C
               S02:0000005A:  00 0E
F00:0110       	dc.w	$0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0	;green
               S02:0000005C:  00 00
               S02:0000005E:  00 20
               S02:00000060:  00 40
               S02:00000062:  00 60
               S02:00000064:  00 80
               S02:00000066:  00 A0
               S02:00000068:  00 C0
               S02:0000006A:  00 E0
F00:0111       	dc.w	$0000,$0200,$0400,$0600,$0800,$0A00,$0C00,$0E00	;blue
               S02:0000006C:  00 00
               S02:0000006E:  02 00
               S02:00000070:  04 00
               S02:00000072:  06 00
               S02:00000074:  08 00
               S02:00000076:  0A 00
               S02:00000078:  0C 00
               S02:0000007A:  0E 00
F00:0112       	dc.w	$0000,$0022,$0044,$0066,$0088,$00AA,$00CC,$00EE	;yellow
               S02:0000007C:  00 00
               S02:0000007E:  00 22
               S02:00000080:  00 44
               S02:00000082:  00 66
               S02:00000084:  00 88
               S02:00000086:  00 AA
               S02:00000088:  00 CC
               S02:0000008A:  00 EE
F00:0113       	dc.w	$0000,$0202,$0404,$0606,$0808,$0A0A,$0C0C,$0E0E	;magenta
               S02:0000008C:  00 00
               S02:0000008E:  02 02
               S02:00000090:  04 04
               S02:00000092:  06 06
               S02:00000094:  08 08
               S02:00000096:  0A 0A
               S02:00000098:  0C 0C
               S02:0000009A:  0E 0E
F00:0114       	dc.w	$0000,$0220,$0440,$0660,$0880,$0AA0,$0CC0,$0EE0	;cyan
               S02:0000009C:  00 00
               S02:0000009E:  02 20
               S02:000000A0:  04 40
               S02:000000A2:  06 60
               S02:000000A4:  08 80
               S02:000000A6:  0A A0
               S02:000000A8:  0C C0
               S02:000000AA:  0E E0
F00:0115       	dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000	;black
               S02:000000AC:  00 00
               S02:000000AE:  00 00
               S02:000000B0:  00 00
               S02:000000B2:  00 00
               S02:000000B4:  00 00
               S02:000000B6:  00 00
               S02:000000B8:  00 00
               S02:000000BA:  00 00
F00:0116       
F00:0117       ;///////////////////////////////////////////////////////////////////////////////
F00:0118       	section	"CODE",code
F00:0119       
F00:0120       ;---------------------------------------
F00:0121       ;VDP_Init
F00:0122       ;
F00:0123       ;Description
F00:0124       ;
F00:0125       ;Calling Convention
F00:0126       ;
F00:0127       ;---------------------------------------
F00:0128       	public	_VDP_Init
F00:0129       _VDP_Init:
F00:0130       	link	a5,#0
               S03:00000000:  4E 55 00 00
F00:0131       
F00:0132       	pea	24
               S03:00000004:  48 78 00 18
F00:0133       	pea	InitVDPValues
               S03:00000008:  48 79 00 00 00 24 [R]
F00:0134       	pea	shadowVdp_address
               S03:0000000E:  48 79 00 00 00 00 [R]
F00:0135       	bsr	_memcpy
               S03:00000014:  61 00 00 00 [R]
F00:0136       	pea	128
               S03:00000018:  48 78 00 80
F00:0137       	pea	InitVDPColorData
               S03:0000001C:  48 79 00 00 00 3C [R]
F00:0138       	pea	_colorBuffer
               S03:00000022:  48 79 00 00 00 28 [R]
F00:0139       	bsr	_memcpy
               S03:00000028:  61 00 00 00 [R]
F00:0140       
F00:0141       	add.w	#24,sp
               S03:0000002C:  4F EF 00 18
F00:0142       
F00:0143       ;set all the colors and VS ram to 0 or whatever they are
F00:0144       	moveq	#0,d0
               S03:00000030:  70 00
F00:0145       	move.l	d0,allocVramStart
               S03:00000032:  23 C0 00 00 00 1C [R]
F00:0146       	move.w	d0,allocVramCurrent
               S03:00000038:  33 C0 00 00 00 24 [R]
F00:0147       	move.l	d0,allocVramEnd
               S03:0000003E:  23 C0 00 00 00 20 [R]
F00:0148       
F00:0149       	unlk	a5
               S03:00000044:  4E 5D
F00:0150       	rts
               S03:00000046:  4E 75
F00:0151       
F00:0152       ;---------------------------------------
F00:0153       ;VDP_CommitShadowRegisters
F00:0154       ;
F00:0155       ;Description
F00:0156       ;
F00:0157       ;Calling Convention
F00:0158       ;
F00:0159       ;---------------------------------------
F00:0160       	public	_VDP_CommitShadowRegisters
F00:0161       _VDP_CommitShadowRegisters:
F00:0162       	link	a5,#0
               S03:00000048:  4E 55 00 00
F00:0163       
F00:0164       	lea	shadowVdp_address,a0
               S03:0000004C:  41 F9 00 00 00 00 [R]
F00:0165       	lea	VDP_CTRL,a1
               S03:00000052:  43 F9 00 C0 00 04
F00:0166       	move.w	#$8000,d0
               S03:00000058:  30 3C 80 00
F00:0167       	moveq	#24-1,d1
               S03:0000005C:  72 17
F00:0168       .loop:	move.b	(a0)+,d0
               S03:0000005E:  10 18
F00:0169       	move.w	d0,(a1)
               S03:00000060:  32 80
F00:0170       	add.w	#$0100,d0
               S03:00000062:  D0 7C 01 00
F00:0171       	dbra	d1,.loop
               S03:00000066:  51 C9 FF F6
F00:0172       
F00:0173       	unlk	a5
               S03:0000006A:  4E 5D
F00:0174       	rts
               S03:0000006C:  4E 75
F00:0175       
F00:0176       ;---------------------------------------
F00:0177       ;_VDP_Enable
F00:0178       ;
F00:0179       ;Description
F00:0180       ;
F00:0181       ;Calling Convention
F00:0182       ;	move.l	#ID,-(sp)
F00:0183       ;	bsr	_VDP_Enable
F00:0184       ;	addq.w	#4,a7
F00:0185       ;
F00:0186       ;---------------------------------------
F00:0187       	public	_VDP_Enable
F00:0188       ;d0 = scratch / index
F00:0189       ;d1 = data to bitwise OR with values
F00:0190       ;a0 = ram table
F00:0191       ;a1 = ram address to modify
F00:0192       _VDP_Enable:
F00:0193       	link	a5,#0
               S03:0000006E:  4E 55 00 00
F00:0194       
F00:0195       ;find out what bit we want to modify, save in a1
F00:0196       	move.l	(8,a5),d0
               S03:00000072:  20 2D 00 08
F00:0197       	cmp.b	#8,d0
               S03:00000076:  B0 3C 00 08
F00:0198       	bcs	.valid
               S03:0000007A:  65 04
F00:0199       	move.l	#UNKNOWN_INPUT,d0
               S03:0000007C:  70 09
F00:0200       	bra	.exit
               S03:0000007E:  60 1A
F00:0201       .valid:	lea	vdpOptionsBits,a0
               S03:00000080:  41 F9 00 00 00 1C [R]
F00:0202       	move.b	(a0,d0),d1
               S03:00000086:  12 30 00 00
F00:0203       
F00:0204       ;what byte of ram we need to apply the OR to.
F00:0205       	lea	vdpOptionsTable,a0
               S03:0000008A:  41 F9 00 00 00 00 [R]
F00:0206       	asl.b	#2,d0
               S03:00000090:  E5 00
F00:0207       	move.l	(a0,d0),a1
               S03:00000092:  22 70 00 00
F00:0208       
F00:0209       ;d1 = value to OR with
F00:0210       ;a1 = address to apply OR to
F00:0211       	or.b	d1,(a1)
               S03:00000096:  83 11
F00:0212       
F00:0213       ;return no error
F00:0214       	moveq	#0,d0
               S03:00000098:  70 00
F00:0215       
F00:0216       ;we are done, we clean our mess
F00:0217       .exit:	unlk	a5
               S03:0000009A:  4E 5D
F00:0218       	rts
               S03:0000009C:  4E 75
F00:0219       
F00:0220       ;---------------------------------------
F00:0221       ;_VDP_Disable
F00:0222       ;
F00:0223       ;Description
F00:0224       ;
F00:0225       ;Calling Convention
F00:0226       ;
F00:0227       ;---------------------------------------
F00:0228       	public	_VDP_Disable
F00:0229       _VDP_Disable:
F00:0230       	link	a5,#0
               S03:0000009E:  4E 55 00 00
F00:0231       
F00:0232       ;find out what bit we want to modify, save in a1
F00:0233       	move.l	(8,a5),d0
               S03:000000A2:  20 2D 00 08
F00:0234       	cmp.b	#8,d0
               S03:000000A6:  B0 3C 00 08
F00:0235       	bcs	.valid
               S03:000000AA:  65 04
F00:0236       	move.l	#UNKNOWN_INPUT,d0
               S03:000000AC:  70 09
F00:0237       	bra	.exit
               S03:000000AE:  60 1C
F00:0238       .valid:	lea	vdpOptionsBits,a0
               S03:000000B0:  41 F9 00 00 00 1C [R]
F00:0239       	move.b	(a0,d0),d1
               S03:000000B6:  12 30 00 00
F00:0240       
F00:0241       ;what byte of ram we need to apply the OR to.
F00:0242       	lea	vdpOptionsTable,a0
               S03:000000BA:  41 F9 00 00 00 00 [R]
F00:0243       	asl.b	#2,d0
               S03:000000C0:  E5 00
F00:0244       	move.l	(a0,d0),a1
               S03:000000C2:  22 70 00 00
F00:0245       
F00:0246       	not.b	d1
               S03:000000C6:  46 01
F00:0247       ;d1 = value to OR with
F00:0248       ;a1 = address to apply OR to
F00:0249       	and.b	d1,(a1)
               S03:000000C8:  C3 11
F00:0250       
F00:0251       ;return no error
F00:0252       	moveq	#0,d0
               S03:000000CA:  70 00
F00:0253       
F00:0254       .exit:	unlk	a5
               S03:000000CC:  4E 5D
F00:0255       	rts
               S03:000000CE:  4E 75
F00:0256       
F00:0257       ;---------------------------------------
F00:0258       ;VDP_SetVideoRegion
F00:0259       ;
F00:0260       ;Sets the Video settings for NTSC or PAL
F00:0261       ;
F00:0262       ;	move.l	#region,-(sp)
F00:0263       ;	bsr	_VDP_SetVideoRegion
F00:0264       ;	addq.w	#4,sp
F00:0265       ;
F00:0266       ;---------------------------------------
F00:0267       	public	_VDP_SetVideoRegion
F00:0268       _VDP_SetVideoRegion:
F00:0269       	link	a5,#0
               S03:000000D0:  4E 55 00 00
F00:0270       
F00:0271       	move.l	(8,a5),d0
               S03:000000D4:  20 2D 00 08
F00:0272       	lea	shadowVdp_ModeReg2,a0
               S03:000000D8:  41 F9 00 00 00 01 [R]
F00:0273       
F00:0274       	tst.l	d0	;AUTO?
               S03:000000DE:  4A 80
F00:0275       	beq	.auto
               S03:000000E0:  67 10
F00:0276       	cmp.b	#VDP_REGION_NTSC,d0
               S03:000000E2:  B0 3C 00 01
F00:0277       	beq	.ntsc
               S03:000000E6:  67 16
F00:0278       	cmp.b	#VDP_REGION_PAL,d0
               S03:000000E8:  B0 3C 00 02
F00:0279       	beq	.pal
               S03:000000EC:  67 16
F00:0280       
F00:0281       ;I don't know what input you gave me but I will just say IDK.
F00:0282       	move.l	#UNKNOWN_INPUT,d0
               S03:000000EE:  70 09
F00:0283       	bra	.exit
               S03:000000F0:  60 16
F00:0284       
F00:0285       ;Just Figure it out ourselves
F00:0286       .auto:	move.w	VDP_CTRL,d0
               S03:000000F2:  30 39 00 C0 00 04
F00:0287       	btst	#0,d0
               S03:000000F8:  08 00 00 00
F00:0288       	bne	.pal
               S03:000000FC:  66 06
F00:0289       
F00:0290       ;North the America's and Japan
F00:0291       .ntsc:	bclr	#3,(a0)
               S03:000000FE:  08 90 00 03
F00:0292       	bra	.exit
               S03:00000102:  60 04
F00:0293       ;Europe
F00:0294       .pal:	bset	#3,(a0)
               S03:00000104:  08 D0 00 03
F00:0295       
F00:0296       ;return no error
F00:0297       .exit:	moveq	#0,d0
               S03:00000108:  70 00
F00:0298       	unlk	a5
               S03:0000010A:  4E 5D
F00:0299       	rts
               S03:0000010C:  4E 75
F00:0300       
F00:0301       ;---------------------------------------
F00:0302       ;VDP_SetScreenWidth
F00:0303       ;
F00:0304       ;Sets the screen width to 32 or 40
F00:0305       ;
F00:0306       ;Calling Convention
F00:0307       ;
F00:0308       ;---------------------------------------
F00:0309       	public	_VDP_SetScreenWidth
F00:0310       _VDP_SetScreenWidth:
F00:0311       	link	a5,#0
               S03:0000010E:  4E 55 00 00
F00:0312       
F00:0313       ;make sure that we get valid input
F00:0314       	move.l	(8,a5),d0
               S03:00000112:  20 2D 00 08
F00:0315       	cmp.b	#3,d0
               S03:00000116:  B0 3C 00 03
F00:0316       	bcs	.valid
               S03:0000011A:  65 04
F00:0317       
F00:0318       ;I don't know what input you gave me but I will just say IDK.
F00:0319       	move.l	#UNKNOWN_INPUT,d0
               S03:0000011C:  70 09
F00:0320       	bra	.exit
               S03:0000011E:  60 1E
F00:0321       
F00:0322       ;set the video setting
F00:0323       .valid:	lea	shadowVdp_ModeReg4,a0
               S03:00000120:  41 F9 00 00 00 0C [R]
F00:0324       	tst.l	d0
               S03:00000126:  4A 80
F00:0325       	bne	.Mode40
               S03:00000128:  66 0A
F00:0326       	bclr	#7,(a0)
               S03:0000012A:  08 90 00 07
F00:0327       	bclr	#0,(a0)
               S03:0000012E:  08 90 00 00
F00:0328       	bra	.skip
               S03:00000132:  60 08
F00:0329       .Mode40:
F00:0330       	bset	#7,(a0)
               S03:00000134:  08 D0 00 07
F00:0331       	bset	#0,(a0)
               S03:00000138:  08 D0 00 00
F00:0332       .skip:	moveq	#0,d0
               S03:0000013C:  70 00
F00:0333       .exit:	unlk	a5
               S03:0000013E:  4E 5D
F00:0334       	rts
               S03:00000140:  4E 75
F00:0335       
F00:0336       ;---------------------------------------
F00:0337       ;VDP_SetHRate
F00:0338       ;
F00:0339       ;sets the H interrupt rate for the VDP
F00:0340       ;68k must be lissoning for them however
F00:0341       ;
F00:0342       ;Calling Convention
F00:0343       ;void	VDP_SetHRate(uint8_t rate);
F00:0344       ;
F00:0345       ;	move.l	#rate,-(sp)
F00:0346       ;	bsr	_VDP_SetHRate
F00:0347       ;	addq.w	#4,sp
F00:0348       ;---------------------------------------
F00:0349       	public	_VDP_SetHRate
F00:0350       _VDP_SetHRate:
F00:0351       	link	a5,#0
               S03:00000142:  4E 55 00 00
F00:0352       	move.l	(8,a5),d0
               S03:00000146:  20 2D 00 08
F00:0353       	move.b	d0,shadowVdp_HRate
               S03:0000014A:  13 C0 00 00 00 0A [R]
F00:0354       	unlk	a5
               S03:00000150:  4E 5D
F00:0355       	rts
               S03:00000152:  4E 75
F00:0356       
F00:0357       ;---------------------------------------
F00:0358       ;VDP_BackgroundColorIndex
F00:0359       ;
F00:0360       ;sets the H interrupt rate for the VDP
F00:0361       ;68k must be lissoning for them however
F00:0362       ;
F00:0363       ;Calling Convention
F00:0364       ;error_t	VDP_BackgroundColorIndex(uint8_t index);
F00:0365       ;
F00:0366       ;	move.l	#index,-(sp)
F00:0367       ;	bsr	_VDP_BackgroundColorIndex
F00:0368       ;	addq.w	#4,sp
F00:0369       ;---------------------------------------
F00:0370       	public	_VDP_BackgroundColorIndex
F00:0371       _VDP_BackgroundColorIndex:
F00:0372       	link	a5,#0
               S03:00000154:  4E 55 00 00
F00:0373       	move.l	(8,a5),d0
               S03:00000158:  20 2D 00 08
F00:0374       	cmp	#64,d0
               S03:0000015C:  B0 7C 00 40
F00:0375       	bcs	.valid
               S03:00000160:  65 04
F00:0376       	moveq	#OUT_OF_BOUNDS,d0
               S03:00000162:  70 08
F00:0377       	bra	.exit
               S03:00000164:  60 08
F00:0378       
F00:0379       .valid:	move.b	d0,shadowVdp_HRate
               S03:00000166:  13 C0 00 00 00 0A [R]
F00:0380       	moveq	#0,d0
               S03:0000016C:  70 00
F00:0381       .exit:	unlk	a5
               S03:0000016E:  4E 5D
F00:0382       	rts
               S03:00000170:  4E 75
F00:0383       
F00:0384       
F00:0385       ;---------------------------------------
F00:0386       ;VDP_DMAColorBuffer
F00:0387       ;
F00:0388       ;Description
F00:0389       ;
F00:0390       ;void	VDP_DMAColorBuffer();
F00:0391       ;
F00:0392       ;	bsr	VDP_DMAColorBuffer
F00:0393       ;
F00:0394       ;---------------------------------------
F00:0395       	public	VDP_DMAColorBuffer
F00:0396       VDP_DMAColorBuffer:
F00:0397       	link	a5,#0
               S03:00000172:  4E 55 00 00
F00:0398       	move.l	d2,-(sp)
               S03:00000176:  2F 02
F00:0399       
F00:0400       ;set auto inc to 2
F00:0401       ;	move.b	#1,shadowVdp_Incr
F00:0402       	lea	VDP_CTRL,a0
               S03:00000178:  41 F9 00 C0 00 04
F00:0403       	move.w	#$8F02,(a0)
               S03:0000017E:  30 BC 8F 02
F00:0404       
F00:0405       ;set length of DMA
F00:0406       	move.w	#$9340,(a0)
               S03:00000182:  30 BC 93 40
F00:0407       	move.w	#$9400,(a0)
               S03:00000186:  30 BC 94 00
F00:0408       
F00:0409       ;set source of DMA
F00:0410       	move.w	#$9500,d0
               S03:0000018A:  30 3C 95 00
F00:0411       	moveq	#3-1,d2
               S03:0000018E:  74 02
F00:0412       	lea	_colorBuffer,a1
               S03:00000190:  43 F9 00 00 00 28 [R]
F00:0413       	move.l	a1,d1
               S03:00000196:  22 09
F00:0414       	lsr.l	#1,d1
               S03:00000198:  E2 89
F00:0415       .loop:	move.b	d1,d0
               S03:0000019A:  10 01
F00:0416       	move.w	d0,(a0)
               S03:0000019C:  30 80
F00:0417       	lsr.l	#8,d1
               S03:0000019E:  E0 89
F00:0418       	add.w	#$0100,d0
               S03:000001A0:  D0 7C 01 00
F00:0419       	dbra	d2,.loop
               S03:000001A4:  51 CA FF F4
F00:0420       
F00:0421       	move.l	#CRAM_DMA_CMD,(a0)
               S03:000001A8:  20 BC C0 00 00 80
F00:0422       	move.l	(sp)+,d2
               S03:000001AE:  24 1F
F00:0423       	unlk	a5
               S03:000001B0:  4E 5D
F00:0424       	rts
               S03:000001B2:  4E 75
F00:0425       
F00:0426       ;---------------------------------------
F00:0427       ;VDP_DMAVSRAMBuffer
F00:0428       ;
F00:0429       ;void	VDP_DMAVSRAMBuffer();
F00:0430       ;
F00:0431       ;	bsr	VDP_DMAVSRAMBuffer
F00:0432       ;
F00:0433       ;---------------------------------------
F00:0434       	public	VDP_DMAVSRAMBuffer
F00:0435       VDP_DMAVSRAMBuffer:
F00:0436       	link	a5,#0
               S03:000001B4:  4E 55 00 00
F00:0437       	move.l	d2,-(sp)
               S03:000001B8:  2F 02
F00:0438       
F00:0439       ;set auto inc to 2
F00:0440       ;	move.b	#1,shadowVdp_Incr
F00:0441       	lea	VDP_CTRL,a0
               S03:000001BA:  41 F9 00 C0 00 04
F00:0442       	move.w	#$8F02,(a0)
               S03:000001C0:  30 BC 8F 02
F00:0443       
F00:0444       ;set length of DMA
F00:0445       	move.w	#$9328,(a0)
               S03:000001C4:  30 BC 93 28
F00:0446       	move.w	#$9400,(a0)
               S03:000001C8:  30 BC 94 00
F00:0447       
F00:0448       ;set source of DMA
F00:0449       	move.w	#$9500,d0
               S03:000001CC:  30 3C 95 00
F00:0450       	moveq	#3-1,d2
               S03:000001D0:  74 02
F00:0451       	lea	_VSRamBuffer,a1
               S03:000001D2:  43 F9 00 00 00 A8 [R]
F00:0452       	move.l	a1,d1
               S03:000001D8:  22 09
F00:0453       	lsr.l	#1,d1
               S03:000001DA:  E2 89
F00:0454       .loop:	move.b	d1,d0
               S03:000001DC:  10 01
F00:0455       	move.w	d0,(a0)
               S03:000001DE:  30 80
F00:0456       	lsr.l	#8,d1
               S03:000001E0:  E0 89
F00:0457       	add.w	#$0100,d0
               S03:000001E2:  D0 7C 01 00
F00:0458       	dbra	d2,.loop
               S03:000001E6:  51 CA FF F4
F00:0459       
F00:0460       	move.l	#VSRAM_DMA_CMD,(a0)
               S03:000001EA:  20 BC 40 00 00 90
F00:0461       	move.l	(sp)+,d2
               S03:000001F0:  24 1F
F00:0462       	unlk	a5
               S03:000001F2:  4E 5D
F00:0463       	rts
               S03:000001F4:  4E 75
F00:0464       
F00:0465       ;---------------------------------------
F00:0466       ;VDP_DMASpriteBuffer
F00:0467       ;
F00:0468       ;void	VDP_DMAVSRAMBuffer();
F00:0469       ;
F00:0470       ;	bsr	VDP_DMASpriteBuffer
F00:0471       ;
F00:0472       ;---------------------------------------
F00:0473       	public	VDP_DMASpriteBuffer
F00:0474       VDP_DMASpriteBuffer:
F00:0475       	link	a5,#0
               S03:000001F6:  4E 55 00 00
F00:0476       	move.l	d2,-(sp)
               S03:000001FA:  2F 02
F00:0477       
F00:0478       ;set auto inc to 2
F00:0479       ;	move.b	#1,shadowVdp_Incr
F00:0480       	lea	VDP_CTRL,a0
               S03:000001FC:  41 F9 00 C0 00 04
F00:0481       	move.w	#$8F02,(a0)
               S03:00000202:  30 BC 8F 02
F00:0482       
F00:0483       ;set length of DMA
F00:0484       	move.w	#$9380,(a0)
               S03:00000206:  30 BC 93 80
F00:0485       	move.w	#$9400,(a0)
               S03:0000020A:  30 BC 94 00
F00:0486       
F00:0487       ;set source of DMA
F00:0488       	move.w	#$9500,d0
               S03:0000020E:  30 3C 95 00
F00:0489       	moveq	#3-1,d2
               S03:00000212:  74 02
F00:0490       	lea	_objectDefinition,a1
               S03:00000214:  43 F9 00 00 00 00 [R]
F00:0491       	move.l	a1,d1
               S03:0000021A:  22 09
F00:0492       	lsr.l	#1,d1
               S03:0000021C:  E2 89
F00:0493       .loop:	move.b	d1,d0
               S03:0000021E:  10 01
F00:0494       	move.w	d0,(a0)
               S03:00000220:  30 80
F00:0495       	lsr.l	#8,d1
               S03:00000222:  E0 89
F00:0496       	add.w	#$0100,d0
               S03:00000224:  D0 7C 01 00
F00:0497       	dbra	d2,.loop
               S03:00000228:  51 CA FF F4
F00:0498       
F00:0499       
F00:0500       	move.l	#VRAM_DMA_CMD,-(sp)
               S03:0000022C:  2F 3C 40 00 00 80
F00:0501       	move.l	#$BE00,-(sp)
               S03:00000232:  2F 3C 00 00 BE 00
F00:0502       	bsr	_VDP_WriteCommand
               S03:00000238:  61 30
F00:0503       	addq.w	#8,sp
               S03:0000023A:  50 4F
F00:0504       
F00:0505       	move.l	d0,(a0)
               S03:0000023C:  20 80
F00:0506       	move.l	(sp)+,d2
               S03:0000023E:  24 1F
F00:0507       	unlk	a5
               S03:00000240:  4E 5D
F00:0508       	rts
               S03:00000242:  4E 75
F00:0509       
F00:0510       ;---------------------------------------
F00:0511       ;VDP_CommitColorBuffer
F00:0512       ;
F00:0513       ;Description
F00:0514       ;
F00:0515       ;Calling Convention
F00:0516       ;void	VDP_CommitColorBuffer();
F00:0517       ;	bsr	VDP_CommitColorBuffer
F00:0518       ;---------------------------------------
F00:0519       	public	_VDP_CommitColorBuffer
F00:0520       _VDP_CommitColorBuffer:
F00:0521       	subq.b	#1,vdpCommitColorBufferFlag
               S03:00000244:  53 39 00 00 00 18 [R]
F00:0522       	rts
               S03:0000024A:  4E 75
F00:0523       
F00:0524       ;---------------------------------------
F00:0525       ;VDP_CommitVSRAMBuffer
F00:0526       ;
F00:0527       ;Description
F00:0528       ;
F00:0529       ;Calling Convention
F00:0530       ;void	VDP_CommitVSRAMBuffer()
F00:0531       ;	bsr	VDP_CommitVSRAMBuffer
F00:0532       ;---------------------------------------
F00:0533       	public	_VDP_CommitVSRAMBuffer
F00:0534       _VDP_CommitVSRAMBuffer:
F00:0535       	subq.b	#1,vdpCommitVSRAMBufferFlag
               S03:0000024C:  53 39 00 00 00 19 [R]
F00:0536       	rts
               S03:00000252:  4E 75
F00:0537       
F00:0538       ;---------------------------------------
F00:0539       ;VDP_CommitVSRAMBuffer
F00:0540       ;
F00:0541       ;Description
F00:0542       ;
F00:0543       ;Calling Convention
F00:0544       ;void	VDP_CommitVSRAMBuffer()
F00:0545       ;	bsr	VDP_CommitVSRAMBuffer
F00:0546       ;---------------------------------------
F00:0547       	public	_VDP_CommitSpriteBuffer
F00:0548       _VDP_CommitSpriteBuffer:
F00:0549       	subq.b	#1,vdpCommitSpriteBufferFlag
               S03:00000254:  53 39 00 00 00 1A [R]
F00:0550       	rts
               S03:0000025A:  4E 75
F00:0551       
F00:0552       ;---------------------------------------
F00:0553       ;VDP_StartCPUHandshake
F00:0554       ;
F00:0555       ;Start's interrupts on the VDP and
F00:0556       ;68k, will stop the cpu and wait.
F00:0557       ;this is also the time where all the
F00:0558       ;shadow registers are committed to the
F00:0559       ;CPU
F00:0560       ;
F00:0561       ;Calling Convention
F00:0562       ;void	VDP_StartCPUHandshake();
F00:0563       ;	bsr	_VDP_StartCPUHandshake
F00:0564       ;---------------------------------------
F00:0565       	public	_VDP_StartCPUHandshake
F00:0566       _VDP_StartCPUHandshake:
F00:0567       ;	link	a5,#0
F00:0568       	move.w	#$8134,(VDP_CTRL)
               S03:0000025C:  33 FC 81 34 00 C0 00 04
F00:0569       	stop	#$2500
               S03:00000264:  4E 72 25 00
F00:0570       ;	unlk	a5
F00:0571       	rts
               S03:00000268:  4E 75
F00:0572       
F00:0573       ;---------------------------------------
F00:0574       ;_VDP_WriteCommand
F00:0575       ;
F00:0576       ;Description
F00:0577       ;
F00:0578       ;Calling Convention
F00:0579       ;void	VDP_WriteCommand(uint16_t address, VDPCmd_t command);
F00:0580       ;
F00:0581       ;	move.l	#command,-(sp)
F00:0582       ;	move.l	#address,-(sp)
F00:0583       ;	bsr	_VDP_WriteCommand
F00:0584       ;	addq.w	#8,sp
F00:0585       ;---------------------------------------
F00:0586       	public	_VDP_WriteCommand
F00:0587       _VDP_WriteCommand:
F00:0588       	link	a5,#0
               S03:0000026A:  4E 55 00 00
F00:0589       	move.l	(8,a5),d0	;addr
               S03:0000026E:  20 2D 00 08
F00:0590       	and.l	#$FFFF,d0
               S03:00000272:  C0 BC 00 00 FF FF
F00:0591       	lsl.l	#2,d0
               S03:00000278:  E5 88
F00:0592       	lsr.w	#2,d0
               S03:0000027A:  E4 48
F00:0593       	swap	d0
               S03:0000027C:  48 40
F00:0594       	or.l	(12,a5),d0	;cmd
               S03:0000027E:  80 AD 00 0C
F00:0595       	unlk	a5
               S03:00000282:  4E 5D
F00:0596       	rts
               S03:00000284:  4E 75
F00:0597       
F00:0598       ;---------------------------------------
F00:0599       ;VDP_AllocMoreTiles
F00:0600       ;
F00:0601       ;allocates more tiles for the linked list
F00:0602       ;
F00:0603       ;Calling Convention
F00:0604       ;	move.l	#numTiles, -(sp)
F00:0605       ;	bsr	VDP_AllocMoreTiles
F00:0606       ;
F00:0607       ;returns:
F00:0608       ;pointer to allocated struct or null
F00:0609       ;
F00:0610       ;---------------------------------------
F00:0611       VDP_AllocMoreTiles:
F00:0612       	link	a5,#0
               S03:00000286:  4E 55 00 00
F00:0613       
F00:0614       	move.l	d2,-(sp)
               S03:0000028A:  2F 02
F00:0615       
F00:0616       	move.l	(8,a5),d2
               S03:0000028C:  24 2D 00 08
F00:0617       	tst.l	d2	;allocating 0 tiles?
               S03:00000290:  4A 82
F00:0618       	beq	.exit	;yes: then wth are you doing?
               S03:00000292:  67 44
F00:0619       	move.l	d2,d0
               S03:00000294:  20 02
F00:0620       
F00:0621       ;check to see if we will run out of tiles
F00:0622       	add.w	allocVramCurrent,d0
               S03:00000296:  D0 79 00 00 00 24 [R]
F00:0623       	cmp.w	#VRAM_MAX_NUMTILES,d0	;will we blow our tile limit?
               S03:0000029C:  B0 7C 08 00
F00:0624       	bls	.ok	;no: continue
               S03:000002A0:  63 04
F00:0625       	moveq	#0,d0	;yes: then we don't bother trying anything else
               S03:000002A2:  70 00
F00:0626       	bra	.exit	;and return null
               S03:000002A4:  60 32
F00:0627       .ok:
F00:0628       
F00:0629       ;we have enough tiles to allocate
F00:0630       ;allocate a new node in the list
F00:0631       	pea	8
               S03:000002A6:  48 78 00 08
F00:0632       	bsr	_malloc
               S03:000002AA:  61 00 00 00 [R]
F00:0633       	addq.w	#4,sp
               S03:000002AE:  58 4F
F00:0634       	tst.l	d0	;did that fail?
               S03:000002B0:  4A 80
F00:0635       	beq	.exit	;yes: now we have a problem
               S03:000002B2:  67 24
F00:0636       
F00:0637       ;no: start filling out the struct
F00:0638       	move.l	d0,a0
               S03:000002B4:  20 40
F00:0639       	move.w	#-1,(VRAM_ALLOC_FREE,a0)
               S03:000002B6:  30 BC FF FF
F00:0640       
F00:0641       ;need to turn this into a physical VRAM address
F00:0642       	move.w	allocVramCurrent,d0
               S03:000002BA:  30 39 00 00 00 24 [R]
F00:0643       	asl.w	#5,d0
               S03:000002C0:  EB 40
F00:0644       	move.w	d0,(VRAM_ALLOC_VRAM,a0)
               S03:000002C2:  31 40 00 02
F00:0645       
F00:0646       	move.w	#0,(VRAM_ALLOC_NEXT,a0)
               S03:000002C6:  31 7C 00 00 00 06
F00:0647       	move.w	d2,(VRAM_ALLOC_NUM,a0)
               S03:000002CC:  31 42 00 04
F00:0648       
F00:0649       ;advance the allocated tiles
F00:0650       	add.w	d2,allocVramCurrent
               S03:000002D0:  D5 79 00 00 00 24 [R]
F00:0651       
F00:0652       ;move to return register
F00:0653       	move.l	a0,d0
               S03:000002D6:  20 08
F00:0654       
F00:0655       .exit:	move.l	(sp)+,d2
               S03:000002D8:  24 1F
F00:0656       	unlk	a5
               S03:000002DA:  4E 5D
F00:0657       	rts
               S03:000002DC:  4E 75
F00:0658       
F00:0659       ;---------------------------------------
F00:0660       ;VSP_SearchForFreeTiles
F00:0661       ;
F00:0662       ;looks for free tiles in video memory
F00:0663       ;
F00:0664       ;Calling Convention
F00:0665       ;	move.l	#numTiles, -(sp)
F00:0666       ;	bsr	VSP_SearchForFreeTiles
F00:0667       ;	addq.w	#4
F00:0668       ;---------------------------------------
F00:0669       ;a0 = previous node
F00:0670       ;a1 = this node
F00:0671       ;a2 = new node if needed
F00:0672       ;
F00:0673       ;
F00:0674       ;d2 = number of tiles requested
F00:0675       
F00:0676       VDP_SearchForFreeTiles:
F00:0677       	link	a5,#0
               S03:000002DE:  4E 55 00 00
F00:0678       	movem.l	d2/a2-a3,-(sp)
               S03:000002E2:  48 E7 20 30
F00:0679       
F00:0680       ;number of tiles requested
F00:0681       	move.l	(8,a5),d2
               S03:000002E6:  24 2D 00 08
F00:0682       
F00:0683       ;start at the beginning of the list
F00:0684       	move.l	allocVramStart,a2
               S03:000002EA:  24 79 00 00 00 1C [R]
F00:0685       
F00:0686       ;is have we reached the end of the block?
F00:0687       .loop:	move.w	a2,d0
               S03:000002F0:  30 0A
F00:0688       	tst.w	d0
               S03:000002F2:  4A 40
F00:0689       	beq	.NoMoreNodes
               S03:000002F4:  67 5A
F00:0690       
F00:0691       	tst.w	(VRAM_ALLOC_FREE,a2)	;is this block free?
               S03:000002F6:  4A 52
F00:0692       	bne	.nodeNotUsable		;no: move onto the next block.
               S03:000002F8:  66 50
F00:0693       	cmp	(VRAM_ALLOC_NUM,a2),d2	;yes: is it enough tiles?
               S03:000002FA:  B4 6A 00 04
F00:0694       	bhi	.nodeNotUsable		;no: move onto the next block
               S03:000002FE:  62 4A
F00:0695       
F00:0696       ;check for any extra tiles
F00:0697       	move.w	(VRAM_ALLOC_NUM,a2),d0
               S03:00000300:  30 2A 00 04
F00:0698       	sub.w	d2,d0		;got any leftover tiles?
               S03:00000304:  90 42
F00:0699       	beq	.exactNumTiles	;no: no need to break down
               S03:00000306:  67 3E
F00:0700       
F00:0701       ;TODO: break down the node into 2, one exact, the other the remainder
F00:0702       ;d0 = number of extra tiles
F00:0703       	move.w	d2,(VRAM_ALLOC_NUM,a2)
               S03:00000308:  35 42 00 04
F00:0704       	move.l	d0,-(sp)
               S03:0000030C:  2F 00
F00:0705       
F00:0706       ;make a new node
F00:0707       	pea	8
               S03:0000030E:  48 78 00 08
F00:0708       	bsr	_malloc
               S03:00000312:  61 00 00 00 [R]
F00:0709       	addq.w	#4,sp
               S03:00000316:  58 4F
F00:0710       	move.l	d0,a3
               S03:00000318:  26 40
F00:0711       	tst.l	d0	;did that fail?
               S03:0000031A:  4A 80
F00:0712       	beq	.exactNumTiles	;just return the block that we found
               S03:0000031C:  67 28
F00:0713       
F00:0714       ;VRAM_ALLOC_FREE equ 0
F00:0715       ;VRAM_ALLOC_VRAM equ 2
F00:0716       ;VRAM_ALLOC_NUM equ 4
F00:0717       ;VRAM_ALLOC_NEXT equ 6
F00:0718       
F00:0719       	move.w	#0,(VRAM_ALLOC_FREE,a3)		;mark new node as free
               S03:0000031E:  36 BC 00 00
F00:0720       	move.l	(sp)+,d1
               S03:00000322:  22 1F
F00:0721       	move.w	d1,(VRAM_ALLOC_NUM,a3)		;number of remaining tiles
               S03:00000324:  37 41 00 04
F00:0722       
F00:0723       ;calculate final vram offset
F00:0724       ;free tiles offset
F00:0725       
F00:0726       
F00:0727       	move.w	(VRAM_ALLOC_VRAM,a2),d1		;address
               S03:00000328:  32 2A 00 02
F00:0728       	move.w	d1,(VRAM_ALLOC_VRAM,a3)
               S03:0000032C:  37 41 00 02
F00:0729       	move.w	(VRAM_ALLOC_NUM,a2),d1
               S03:00000330:  32 2A 00 04
F00:0730       	asl.w	#5,d1
               S03:00000334:  EB 41
F00:0731       	add.w	d1,(VRAM_ALLOC_VRAM,a3)
               S03:00000336:  D3 6B 00 02
F00:0732       ;take the number of tiles on the previous node and calculate the start pos
F00:0733       ;in vram
F00:0734       
F00:0735       ;new.next = this.next
F00:0736       ;this.next = new
F00:0737       	move.w	(VRAM_ALLOC_NEXT,a2),d1
               S03:0000033A:  32 2A 00 06
F00:0738       	move.w	d1,(VRAM_ALLOC_NEXT,a3)
               S03:0000033E:  37 41 00 06
F00:0739       	move.w	a3,(VRAM_ALLOC_NEXT,a2)
               S03:00000342:  35 4B 00 06
F00:0740       
F00:0741       
F00:0742       .exactNumTiles:
F00:0743       	move.l	a2,d0	;return this node
               S03:00000346:  20 0A
F00:0744       	bra	.exit
               S03:00000348:  60 08
F00:0745       ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
F00:0746       ;we get here when we need to goto the next node
F00:0747       .nodeNotUsable:
F00:0748       	move.w	(VRAM_ALLOC_NEXT,a2),a2
               S03:0000034A:  34 6A 00 06
F00:0749       	bra	.loop
               S03:0000034E:  60 A0
F00:0750       
F00:0751       .NoMoreNodes:
F00:0752       	moveq	#0,d0
               S03:00000350:  70 00
F00:0753       .exit:	movem.l	(sp)+,d2/a2-a3
               S03:00000352:  4C DF 0C 04
F00:0754       	unlk	a5
               S03:00000356:  4E 5D
F00:0755       	rts
               S03:00000358:  4E 75
F00:0756       
F00:0757       ;---------------------------------------
F00:0758       ;VDP_AllocVram
F00:0759       ;
F00:0760       ;Description:
F00:0761       ;attempts to find space in vram to reserve
F00:0762       ;for any purpose. I.E sprites and backgrounds
F00:0763       ;
F00:0764       ;Calling Convention
F00:0765       ;uint8_t* VDP_AllocateVram(uint8_t numTiles);
F00:0766       ;
F00:0767       ;	pea	numTiles
F00:0768       ;	bsr	_VDP_AllocateVram
F00:0769       ;
F00:0770       ;---------------------------------------
F00:0771       ;d2 = requested size
F00:0772       
F00:0773       ;VRAM_ALLOC_FREE equ 0
F00:0774       ;VRAM_ALLOC_VRAM equ 2
F00:0775       ;VRAM_ALLOC_NUM equ 4
F00:0776       ;VRAM_ALLOC_NEXT equ 6
F00:0777       
F00:0778       ;allocVramStart	ds.l	1
F00:0779       ;allocVramEnd	ds.l	1
F00:0780       ;allocVramCurrent ds.w	1
F00:0781       
F00:0782       	public	_VDP_AllocVram
F00:0783       _VDP_AllocVram:
F00:0784       	link	a5,#0
               S03:0000035A:  4E 55 00 00
F00:0785       
F00:0786       ;search for any free tiles
F00:0787       	move.l	(8,a5),d0
               S03:0000035E:  20 2D 00 08
F00:0788       	move.l	d0,-(sp)
               S03:00000362:  2F 00
F00:0789       	bsr	VDP_SearchForFreeTiles
               S03:00000364:  61 00 FF 78
F00:0790       	addq.w	#4,sp
               S03:00000368:  58 4F
F00:0791       	tst.l	d0		;found any?
               S03:0000036A:  4A 80
F00:0792       	beq	.noFreeTiles	;no: allocate more
               S03:0000036C:  67 08
F00:0793       
F00:0794       ;yes: reserve the node and return it
F00:0795       	move.l	d0,a0
               S03:0000036E:  20 40
F00:0796       	move.w	#-1,(VRAM_ALLOC_FREE,a0)
               S03:00000370:  30 BC FF FF
F00:0797       	bra	.exit
               S03:00000374:  60 38
F00:0798       
F00:0799       ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
F00:0800       .noFreeTiles:
F00:0801       ;allocate more tiles in video memory
F00:0802       	move.l	(8,a5),d0
               S03:00000376:  20 2D 00 08
F00:0803       	move.l	d0,-(sp)
               S03:0000037A:  2F 00
F00:0804       	bsr	VDP_AllocMoreTiles
               S03:0000037C:  61 00 FF 08
F00:0805       	addq.w	#4,sp
               S03:00000380:  58 4F
F00:0806       	tst.l	d0	;did that fail?
               S03:00000382:  4A 80
F00:0807       	beq	.exit	;yes: well return null then
               S03:00000384:  67 28
F00:0808       
F00:0809       
F00:0810       	tst.l	allocVramStart	;is this the 1st time calling this?
               S03:00000386:  4A B9 00 00 00 1C [R]
F00:0811       	bne	.notFirst	;no: no need to set the head of the linked list
               S03:0000038C:  66 0E
F00:0812       	move.l	d0,allocVramStart	;yes: make this node the head
               S03:0000038E:  23 C0 00 00 00 1C [R]
F00:0813       	move.l	d0,allocVramEnd		;also make this the end
               S03:00000394:  23 C0 00 00 00 20 [R]
F00:0814       	bra	.exit
               S03:0000039A:  60 12
F00:0815       
F00:0816       ;link to the end of the list and point allocVramEnd to it
F00:0817       .notFirst:
F00:0818       	move.l	d0,a0
               S03:0000039C:  20 40
F00:0819       	move.l	allocVramEnd,a1
               S03:0000039E:  22 79 00 00 00 20 [R]
F00:0820       	move.w	a0,(VRAM_ALLOC_NEXT,a1)
               S03:000003A4:  33 48 00 06
F00:0821       	move.l	a0,allocVramEnd
               S03:000003A8:  23 C8 00 00 00 20 [R]
F00:0822       
F00:0823       .exit:	unlk	a5
               S03:000003AE:  4E 5D
F00:0824       	rts
               S03:000003B0:  4E 75
F00:0825       
F00:0826       ;---------------------------------------
F00:0827       ;_VDP_FreeVram
F00:0828       ;
F00:0829       ;takes a pointer to a VDPVramNode_t
F00:0830       ;and frees the tiles, combining them
F00:0831       ;with other blocks if nessesary
F00:0832       ;
F00:0833       ;Calling Convention
F00:0834       ;	move.l	node, -(sp)
F00:0835       ;	bsr	_VDP_FreeVram
F00:0836       ;	addq.w	#4,sp
F00:0837       ;
F00:0838       ;VDP_FreeVram(VDPVramNode_t* node);
F00:0839       ;---------------------------------------
F00:0840       ;a0 =  this block
F00:0841       
F00:0842       	public	_VDP_FreeVram
F00:0843       _VDP_FreeVram:
F00:0844       	link	a5,#0
               S03:000003B2:  4E 55 00 00
F00:0845       
F00:0846       	move.l	(8,a5),a0
               S03:000003B6:  20 6D 00 08
F00:0847       
F00:0848       ;free the block of tiles
F00:0849       	move.w	#0,(VRAM_ALLOC_FREE,a0)
               S03:000003BA:  30 BC 00 00
F00:0850       
F00:0851       ;VRAM_ALLOC_FREE equ 0
F00:0852       ;VRAM_ALLOC_VRAM equ 2
F00:0853       ;VRAM_ALLOC_NUM equ 4
F00:0854       ;VRAM_ALLOC_NEXT equ 6
F00:0855       
F00:0856       ;try to concatinate block together
F00:0857       ;a0 = this block
F00:0858       ;a1 = next block
F00:0859       	move.l	allocVramStart,a0
               S03:000003BE:  20 79 00 00 00 1C [R]
F00:0860       .loop:	move.w	a0,d0
               S03:000003C4:  30 08
F00:0861       	tst.w	d0	;is this block null?
               S03:000003C6:  4A 40
F00:0862       	beq	.exit	;yes: no need to go any more
               S03:000003C8:  67 30
F00:0863       	tst.w	(VRAM_ALLOC_FREE,a0)	;is this block free?
               S03:000003CA:  4A 50
F00:0864       	bne	.blockNotFree		;no: skip to next
               S03:000003CC:  66 26
F00:0865       
F00:0866       	move.w	(VRAM_ALLOC_NEXT,a0),a1	;yes: grab the next block
               S03:000003CE:  32 68 00 06
F00:0867       	cmp.w	#0,a1	;is it null?
               S03:000003D2:  B2 FC 00 00
F00:0868       	beq	.noNext	;yes: at the end of the list
               S03:000003D6:  67 22
F00:0869       
F00:0870       	tst.w	(VRAM_ALLOC_FREE,a1)	;is the next block free?
               S03:000003D8:  4A 51
F00:0871       	bne	.blockNotFree
               S03:000003DA:  66 18
F00:0872       
F00:0873       ;we get here when this block and the next block are free, concatinate
F00:0874       	move.w	(VRAM_ALLOC_NUM,a1),d0
               S03:000003DC:  30 29 00 04
F00:0875       	add.w	d0,(VRAM_ALLOC_NUM,a0)
               S03:000003E0:  D1 68 00 04
F00:0876       	move.w	(VRAM_ALLOC_NEXT,a1),d0
               S03:000003E4:  30 29 00 06
F00:0877       	move.w	d0,(VRAM_ALLOC_NEXT,a0)
               S03:000003E8:  31 40 00 06
F00:0878       
F00:0879       ;a1 now needs to be destroyed
F00:0880       	move.l	a1,-(sp)
               S03:000003EC:  2F 09
F00:0881       	bsr	_free
               S03:000003EE:  61 00 00 00 [R]
F00:0882       	addq.w	#4,sp
               S03:000003F2:  58 4F
F00:0883       
F00:0884       .blockNotFree:
F00:0885       	move.w	(VRAM_ALLOC_NEXT,a0),a0
               S03:000003F4:  30 68 00 06
F00:0886       	bra	.loop
               S03:000003F8:  60 CA
F00:0887       
F00:0888       .noNext:
F00:0889       
F00:0890       .exit:	unlk	a5
               S03:000003FA:  4E 5D
F00:0891       	rts
               S03:000003FC:  4E 75
F00:0892       
F00:0893       ;---------------------------------------
F00:0894       ;Function Name
F00:0895       ;
F00:0896       ;Description
F00:0897       ;
F00:0898       ;Calling Convention
F00:0899       ;
F00:0900       ;---------------------------------------
F00:0901       


Sections:
S01  BSS
S02  DATA
S03  CODE


Sources:
F00  vdpAbstraction.asm
F01  vdpAbstraction.inc
F02  errno.inc


Symbols:
_free IMP REF 
 _VDP_FreeVram .noNext LAB (0x3fa) sec=CODE 
 _VDP_FreeVram .blockNotFree LAB (0x3f4) sec=CODE 
 _VDP_FreeVram .exit LAB (0x3fa) sec=CODE 
 _VDP_FreeVram .loop LAB (0x3c4) sec=CODE 
_VDP_FreeVram LAB (0x3b2) UNUSED EXPORT sec=CODE 
 _VDP_AllocVram .notFirst LAB (0x39c) sec=CODE 
 _VDP_AllocVram .exit LAB (0x3ae) sec=CODE 
 _VDP_AllocVram .noFreeTiles LAB (0x376) sec=CODE 
_VDP_AllocVram LAB (0x35a) UNUSED EXPORT sec=CODE 
 VDP_SearchForFreeTiles .exit LAB (0x352) sec=CODE 
 VDP_SearchForFreeTiles .exactNumTiles LAB (0x346) sec=CODE 
 VDP_SearchForFreeTiles .nodeNotUsable LAB (0x34a) sec=CODE 
 VDP_SearchForFreeTiles .NoMoreNodes LAB (0x350) sec=CODE 
 VDP_SearchForFreeTiles .loop LAB (0x2f0) sec=CODE 
VDP_SearchForFreeTiles LAB (0x2de) sec=CODE 
_malloc IMP REF 
 VDP_AllocMoreTiles .ok LAB (0x2a6) sec=CODE 
 VDP_AllocMoreTiles .exit LAB (0x2d8) sec=CODE 
VDP_AllocMoreTiles LAB (0x286) sec=CODE 
_VDP_StartCPUHandshake LAB (0x25c) UNUSED EXPORT sec=CODE 
_VDP_CommitSpriteBuffer LAB (0x254) UNUSED EXPORT sec=CODE 
_VDP_CommitVSRAMBuffer LAB (0x24c) UNUSED EXPORT sec=CODE 
_VDP_CommitColorBuffer LAB (0x244) UNUSED EXPORT sec=CODE 
_VDP_WriteCommand LAB (0x26a) EXPORT sec=CODE 
 VDP_DMASpriteBuffer .loop LAB (0x21e) sec=CODE 
_objectDefinition IMP REF 
VDP_DMASpriteBuffer LAB (0x1f6) UNUSED EXPORT sec=CODE 
 VDP_DMAVSRAMBuffer .loop LAB (0x1dc) sec=CODE 
VDP_DMAVSRAMBuffer LAB (0x1b4) UNUSED EXPORT sec=CODE 
 VDP_DMAColorBuffer .loop LAB (0x19a) sec=CODE 
VDP_DMAColorBuffer LAB (0x172) UNUSED EXPORT sec=CODE 
 _VDP_BackgroundColorIndex .exit LAB (0x16e) sec=CODE 
 _VDP_BackgroundColorIndex .valid LAB (0x166) sec=CODE 
_VDP_BackgroundColorIndex LAB (0x154) UNUSED EXPORT sec=CODE 
_VDP_SetHRate LAB (0x142) UNUSED EXPORT sec=CODE 
 _VDP_SetScreenWidth .skip LAB (0x13c) sec=CODE 
 _VDP_SetScreenWidth .Mode40 LAB (0x134) sec=CODE 
 _VDP_SetScreenWidth .exit LAB (0x13e) sec=CODE 
 _VDP_SetScreenWidth .valid LAB (0x120) sec=CODE 
_VDP_SetScreenWidth LAB (0x10e) UNUSED EXPORT sec=CODE 
 _VDP_SetVideoRegion .exit LAB (0x108) sec=CODE 
 _VDP_SetVideoRegion .pal LAB (0x104) sec=CODE 
 _VDP_SetVideoRegion .ntsc LAB (0xfe) sec=CODE 
 _VDP_SetVideoRegion .auto LAB (0xf2) sec=CODE 
_VDP_SetVideoRegion LAB (0xd0) UNUSED EXPORT sec=CODE 
 _VDP_Disable .exit LAB (0xcc) sec=CODE 
 _VDP_Disable .valid LAB (0xb0) sec=CODE 
_VDP_Disable LAB (0x9e) UNUSED EXPORT sec=CODE 
 _VDP_Enable .exit LAB (0x9a) sec=CODE 
 _VDP_Enable .valid LAB (0x80) sec=CODE 
_VDP_Enable LAB (0x6e) UNUSED EXPORT sec=CODE 
 _VDP_CommitShadowRegisters .loop LAB (0x5e) sec=CODE 
_VDP_CommitShadowRegisters LAB (0x48) UNUSED EXPORT sec=CODE 
_memcpy IMP REF 
_VDP_Init LAB (0x0) UNUSED EXPORT sec=CODE 
InitVDPColorData LAB (0x3c) REF sec=DATA 
InitVDPValues LAB (0x24) REF sec=DATA 
vdpOptionsBits LAB (0x1c) REF sec=DATA 
vdpOptionsTable LAB (0x0) REF sec=DATA 
_VSRamBuffer LAB (0xa8) EXPORT REF sec=BSS 
_colorBuffer LAB (0x28) EXPORT REF sec=BSS 
_hScroll LAB (0x26) UNUSED EXPORT sec=BSS 
allocVramCurrent LAB (0x24) REF sec=BSS 
allocVramEnd LAB (0x20) REF sec=BSS 
allocVramStart LAB (0x1c) REF sec=BSS 
vdpCommitSpriteBufferFlag LAB (0x1a) EXPORT REF sec=BSS 
vdpCommitVSRAMBufferFlag LAB (0x19) EXPORT REF sec=BSS 
vdpCommitColorBufferFlag LAB (0x18) EXPORT REF sec=BSS 
shadowVdp_DMA_S_High LAB (0x17) UNUSED sec=BSS 
shadowVdp_DMA_S_Mid LAB (0x16) UNUSED sec=BSS 
shadowVdp_DMA_S_Low LAB (0x15) UNUSED sec=BSS 
shadowVdp_DMA_L_High LAB (0x14) UNUSED sec=BSS 
shadowVdp_DMA_L_Low LAB (0x13) UNUSED sec=BSS 
shadowVdp_WinY LAB (0x12) UNUSED sec=BSS 
shadowVdp_WinX LAB (0x11) UNUSED sec=BSS 
shadowVdp_Size LAB (0x10) UNUSED sec=BSS 
shadowVdp_Incr LAB (0xf) UNUSED sec=BSS 
shadowVdp_HScroll LAB (0xd) UNUSED sec=BSS 
shadowVdp_ModeReg4 LAB (0xc) REF sec=BSS 
shadowVdp_ModeReg3 LAB (0xb) REF sec=BSS 
shadowVdp_HRate LAB (0xa) REF sec=BSS 
shadowVdp_BGColor LAB (0x7) UNUSED sec=BSS 
shadowVdp_Sprite LAB (0x5) UNUSED sec=BSS 
shadowVdp_PlaneB LAB (0x4) UNUSED sec=BSS 
shadowVdp_Window LAB (0x3) UNUSED sec=BSS 
shadowVdp_PlaneA LAB (0x2) UNUSED sec=BSS 
shadowVdp_ModeReg2 LAB (0x1) REF sec=BSS 
shadowVdp_ModeReg1 LAB (0x0) REF sec=BSS 
shadowVdp_address LAB (0x0) EXPORT REF sec=BSS 
VRAM_MAX_NUMTILES EXPR(2048=0x800) EQU 
VRAM_ALLOC_NEXT EXPR(6=0x6) EQU 
VRAM_ALLOC_NUM EXPR(4=0x4) EQU 
VRAM_ALLOC_VRAM EXPR(2=0x2) EQU 
VRAM_ALLOC_FREE EXPR(0=0x0) EQU 
UNKNOWN_INPUT EXPR(9=0x9) EQU 
OUT_OF_BOUNDS EXPR(8=0x8) EQU 
OUT_OF_MEMORY EXPR(7=0x7) UNUSED EQU 
TOO_LONG EXPR(6=0x6) UNUSED EQU 
DEADLOCK EXPR(5=0x5) UNUSED EQU 
IO_ERROR EXPR(4=0x4) UNUSED EQU 
BAD_ADDRESS EXPR(3=0x3) UNUSED EQU 
DOES_NOT_EXIST EXPR(2=0x2) UNUSED EQU 
FILE_NOT_FOUND EXPR(1=0x1) UNUSED EQU 
NONE EXPR(0=0x0) UNUSED EQU 
VSRAM_DMA_CMD EXPR(1073741968=0x40000090) EQU 
CRAM_DMA_CMD EXPR(-1073741696=0xc0000080) EQU 
VRAM_DMA_CMD EXPR(1073741952=0x40000080) EQU 
VSRAM_READ_CMD EXPR(32=0x20) UNUSED EQU 
CRAM_READ_CMD EXPR(64=0x40) UNUSED EQU 
VRAM_READ_CMD EXPR(0=0x0) UNUSED EQU 
VSRAM_WRITE_CMD EXPR(1073741840=0x40000010) UNUSED EQU 
CRAM_WRITE_CMD EXPR(-1073741824=0xc0000000) UNUSED EQU 
VRAM_WRITE_CMD EXPR(1073741824=0x40000000) UNUSED EQU 
VSRAM_SIZE EXPR(80=0x50) EQU 
CRAM_SIZE EXPR(128=0x80) EQU 
VRAM_SIZE EXPR(65536=0x10000) UNUSED EQU 
DMA_TYPE_COPY EXPR(2=0x2) UNUSED EQU 
DMA_TYPE_FILL EXPR(1=0x1) UNUSED EQU 
DMA_TYPE_MAIN EXPR(0=0x0) UNUSED EQU 
VDP_REGION_PAL EXPR(2=0x2) EQU 
VDP_REGION_NTSC EXPR(1=0x1) EQU 
VDP_HVCOUNTER EXPR(12582920=0xc00008) UNUSED EQU 
VDP_CTRL EXPR(12582916=0xc00004) EQU 
VDP_DATA EXPR(12582912=0xc00000) UNUSED EQU 
_MOVEMBYTES EXPR(12=0xc) INTERNAL 
 MOVEMSIZE EXPR(4=0x4) INTERNAL 
_MOVEMREGS EXPR(3076=0xc04) INTERNAL 
__LINE__ EXPR(901=0x385) INTERNAL 
__FO EXPR(0=0x0) INTERNAL 
__RS EXPR(0=0x0) INTERNAL 
REPTN EXPR(-1=0xffffffff) INTERNAL 
__VASM EXPR(1=0x1) INTERNAL 
__UNIXFS EXPR(0=0x0) INTERNAL 

There have been no errors.
