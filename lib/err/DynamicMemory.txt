F00:0001       ;===============================================================================
F00:0002       ;DynamicMemory.asm
F00:0003       ;===============================================================================
F00:0004       ;C style memory allocation.
F00:0005       ;
F00:0006       ;This file is ment to be used with both asm and C files, so C function calls
F00:0007       ;are used
F00:0008       ;
F00:0009       ;void initHeap(void);
F00:0010       ;void* malloc(size_t size);
F00:0011       ;void* calloc(size_t items, size_t size);
F00:0012       ;void free(void* ptr);
F00:0013       ;void* realloc(void* ptr, size_t size);
F00:0014       ;
F00:0015       ;These functions are defined as a local scope only
F00:0016       ;int 	brk(void* addr);
F00:0017       ;void*	sbrk(size_t increment);
F00:0018       ;
F00:0019       ;
F00:0020       ;
F00:0021       ;On success, brk() returns zero.  On error, -1 is returned, and
F00:0022       ;      errno is set to ENOMEM.
F00:0023       ;
F00:0024       ;      On success, sbrk() returns the previous program break.  (If the
F00:0025       ;      break was increased, then this value is a pointer to the start of
F00:0026       ;      the newly allocated memory).  On error, (void *) -1 is returned,
F00:0027       ;      and errno is set to ENOMEM.
F00:0028       ;-------------------------------------------------------------------------------
F00:0029       
F00:0030       	include "errno.inc"
F01:0001       ;===============================================================================
F01:0002       ;errno.inc
F01:0003       ;===============================================================================
F01:0004       ;Defines the error codes for things supporting it, should be the same as in
F01:0005       ;errno.h
F01:0006       ;-------------------------------------------------------------------------------
F01:0007       
F01:0008       NONE equ 0
F01:0009       FILE_NOT_FOUND equ 1
F01:0010       DOES_NOT_EXIST equ 2
F01:0011       BAD_ADDRESS equ 3
F01:0012       IO_ERROR equ 4
F01:0013       DEADLOCK equ 5
F01:0014       TOO_LONG equ 6
F01:0015       OUT_OF_MEMORY equ 7
F01:0016       OUT_OF_BOUNDS equ 8
F01:0017       UNKNOWN_INPUT equ 9
F01:0018       
F01:0019       ;///////////////////////////////////////////////////////////////////////////////
F01:0020       	section	"BSS",bss
F01:0021       
F01:0022       ;	public	_errno
F01:0023       ;_errno	ds.l	1
F01:0024       
F01:0025       ;///////////////////////////////////////////////////////////////////////////////
F01:0026       
F01:0027       
F00:0031       
F00:0032       ;ERROR numbers
F00:0033       ERROR_NONE equ NONE
F00:0034       ERROR_ENOMEM equ OUT_OF_MEMORY
F00:0035       
F00:0036       ;Memory size
F00:0037       HEAP_SIZE_TOTAL equ $5fff
F00:0038       
F00:0039       ;malloc heap access constants
F00:0040       HEAP_PREV equ -8
F00:0041       HEAP_FREE equ -6
F00:0042       HEAP_SIZE equ -4
F00:0043       HEAP_NEXT equ -2
F00:0044       
F00:0045       ;malloc struct, due to only having 8 bytes using addq,
F00:0046       ;we need to do some pointer hacks to keep things in size.
F00:0047       ;All 32-bit pointers are chopped to 16-bit, as the upper 16 never change
F00:0048       ;
F00:0049       ;example pointer
F00:0050       ;-8 = prev
F00:0051       ;-7 = prev
F00:0052       ;-6 = free
F00:0053       ;-5 = free
F00:0054       ;-4 = size
F00:0055       ;-3 = size
F00:0056       ;-2 = next
F00:0057       ;-1 = next
F00:0058       ;
F00:0059       ;all memory access should be even, as reading odd addresses at not
F00:0060       ;byte level causes exeptions on the 68k
F00:0061       
F00:0062       ;here are the function calls generated by vbcc and myself.
F00:0063       ;	bsr	initHeap
F00:0064       ;
F00:0065       ;	pea	size
F00:0066       ;	bsr	_malloc
F00:0067       ;
F00:0068       ;	pea	size
F00:0069       ;	pea	items
F00:0070       ;	bsr	_calloc
F00:0071       ;
F00:0072       ;	pea	ptr
F00:0073       ;	bsr	_free
F00:0074       ;
F00:0075       ;	pea	size
F00:0076       ;	pea	ptr
F00:0077       ;	bsr	_realloc
F00:0078       
F00:0079       ;///////////////////////////////////////////////////////////////////////////////
F00:0080       	section	"BSS",bss
F00:0081       
F00:0082       programBreak	ds.l	1
F00:0083       globalBase	ds.l	1
F00:0084       ;///////////////////////////////////////////////////////////////////////////////
F00:0085       	section	"HEAP",bss
F00:0086       
F00:0087       heap	ds.b	HEAP_SIZE_TOTAL
F00:0088       ;///////////////////////////////////////////////////////////////////////////////
F00:0089       	section	"DATA",data
F00:0090       ;///////////////////////////////////////////////////////////////////////////////
F00:0091       	section	"CODE",code
F00:0092       
F00:0093       ;---------------------------------------
F00:0094       ;brk
F00:0095       ;
F00:0096       ;sets the program break to a address
F00:0097       ;
F00:0098       ;	pea	address
F00:0099       ;	bsr	brk
F00:0100       ;---------------------------------------
F00:0101       brk:	link	a5,#0
               S04:00000000:  4E 55 00 00
F00:0102       	move.l	(8,a5),d0	;access params (address)
               S04:00000004:  20 2D 00 08
F00:0103       	cmpi.l	#heap,d0	;is this address before the start of the heap?
               S04:00000008:  0C 80 00 00 00 00 [R]
F00:0104       	blt	.error 		;yes: flag error and return -1
               S04:0000000E:  6D 12
F00:0105       	cmpi.l	#heap+HEAP_SIZE_TOTAL,d0	;no: is this past the heap?
               S04:00000010:  0C 80 00 00 5F FF [R]
F00:0106       	bgt	.error 		;yes: flag error and return -1
               S04:00000016:  6E 0A
F00:0107           	move.l	d0,programBreak	;no:its in range of heap, mark new data
               S04:00000018:  23 C0 00 00 00 00 [R]
F00:0108           	moveq	#0,d0
               S04:0000001E:  70 00
F00:0109           	bra	.exit
               S04:00000020:  60 0A
F00:0110       .error:	move.b	#ERROR_ENOMEM,_errno
               S04:00000022:  13 FC 00 07 00 00 00 00 [R]
F00:0111       	move.l	#-1,d0
               S04:0000002A:  70 FF
F00:0112       .exit:	unlk	a5
               S04:0000002C:  4E 5D
F00:0113       	move.l	(sp),(4,sp)	;deallocate parameters
               S04:0000002E:  2F 57 00 04
F00:0114       	lea	(4,sp),sp
               S04:00000032:  58 8F
F00:0115       	rts
               S04:00000034:  4E 75
F00:0116       
F00:0117       ;---------------------------------------
F00:0118       ;sbrk
F00:0119       ;
F00:0120       ;increments the program break by
F00:0121       ;a set amount.
F00:0122       ;
F00:0123       ;	pea 	size
F00:0124       ;	bsr	sbrk
F00:0125       ;---------------------------------------
F00:0126       sbrk:	link	a5,#0
               S04:00000036:  4E 55 00 00
F00:0127       	move.l	(8,a5),d0	;access params (address)
               S04:0000003A:  20 2D 00 08
F00:0128       	add.l 	programBreak,d0	;do the addition to find final programBreak
               S04:0000003E:  D0 B9 00 00 00 00 [R]
F00:0129       	cmpi.l 	#heap,d0	;is this address before the start of the heap?
               S04:00000044:  0C 80 00 00 00 00 [R]
F00:0130       	blt	.error 		;yes: flag error and return -1
               S04:0000004A:  6D 10
F00:0131       	cmpi.l	#heap+HEAP_SIZE_TOTAL,d0	;no: is this past the heap?
               S04:0000004C:  0C 80 00 00 5F FF [R]
F00:0132       	bgt	.error 		;yes: flag error and return -1
               S04:00000052:  6E 08
F00:0133       	move.l 	d0,programBreak	;no:its in range of heap, mark new data
               S04:00000054:  23 C0 00 00 00 00 [R]
F00:0134       	bra 	.exit
               S04:0000005A:  60 0A
F00:0135       .error:	move.b 	#ERROR_ENOMEM,_errno
               S04:0000005C:  13 FC 00 07 00 00 00 00 [R]
F00:0136       	move.l 	#-1,d0
               S04:00000064:  70 FF
F00:0137       .exit:	unlk	a5
               S04:00000066:  4E 5D
F00:0138       	move.l	(sp),(4,sp)	;deallocate parameters
               S04:00000068:  2F 57 00 04
F00:0139       	lea	(4,sp),sp
               S04:0000006C:  58 8F
F00:0140       	rts
               S04:0000006E:  4E 75
F00:0141       
F00:0142       ;---------------------------------------
F00:0143       ;findFreeBlock
F00:0144       ;
F00:0145       ;goes through the whole heap allocated
F00:0146       ;space looking for a free block that is
F00:0147       ;big enough.
F00:0148       ;either return the pointer to the free
F00:0149       ;or null (0). This also assums that then
F00:0150       ;parent method has already checked for 0's
F00:0151       ;
F00:0152       ;	pea 	size
F00:0153       ;	bsr	findFreeBlock
F00:0154       ;---------------------------------------
F00:0155       ;d0 = scratch
F00:0156       ;d1 = 2nd scratch / new block of memory
F00:0157       ;a0 = linked list pointer
F00:0158       
F00:0159       findFreeBlock:
F00:0160       	link	a5,#0
               S04:00000070:  4E 55 00 00
F00:0161       	move.l	(8,a5),d0	;access params (size)
               S04:00000074:  20 2D 00 08
F00:0162       
F00:0163       	move.l	globalBase,a0
               S04:00000078:  20 79 00 00 00 04 [R]
F00:0164       .loop:	tst.w	(HEAP_FREE,a0)	;is this block free?
               S04:0000007E:  4A 68 FF FA
F00:0165       	bne 	.notUsable	;no: skip to the next block
               S04:00000082:  66 5E
F00:0166       	cmp.w	(HEAP_SIZE,a0),d0	;yes: is this block big enough?
               S04:00000084:  B0 68 FF FC
F00:0167       	bhi	.notUsable		;no: continue
               S04:00000088:  62 58
F00:0168       
F00:0169       ;we can try to break blocks smaller here
F00:0170       	addq.w	#8,d0
               S04:0000008A:  50 40
F00:0171       	cmp.w	(HEAP_SIZE,a0),d0	;is this block big enough to break down?
               S04:0000008C:  B0 68 FF FC
F00:0172       	bhi	.cantBreakDown		;no: continue
               S04:00000090:  62 46
F00:0173       
F00:0174       ;yes: time to do some memory hacks
F00:0175       	move.l	a0,a1	;clone the pointer
               S04:00000092:  22 48
F00:0176       	move.w	(HEAP_SIZE,a0),d1	;total heap size
               S04:00000094:  32 28 FF FC
F00:0177       	move.l	(8,a5),d0
               S04:00000098:  20 2D 00 08
F00:0178       	move.w	d0,(HEAP_SIZE,a0)
               S04:0000009C:  31 40 FF FC
F00:0179       	subq.w	#8,d1	;subtract memory for metts data
               S04:000000A0:  51 41
F00:0180       	sub.w	d0,d1	;subtract memory needed for the findFreeBlock request
               S04:000000A2:  92 40
F00:0181       
F00:0182       ;d1 = new amount of memory that this new block will hold
F00:0183       	tst.w	d1	;is the amount of free memory 0?
               S04:000000A4:  4A 41
F00:0184       	beq	.cantBreakDown	;yes: then don't try it, as its a wast of memory
               S04:000000A6:  67 30
F00:0185       
F00:0186       ;no: make the new pointer and populate metta data
F00:0187       	addq.w	#8,a1	;advance pointer by metta data bytes
               S04:000000A8:  50 49
F00:0188       	add.w	d0,a1	;advance pointer by requested bytes
               S04:000000AA:  D2 C0
F00:0189       
F00:0190       ;start inserting the new list into the heap
F00:0191       	move.w	(HEAP_NEXT,a0),d0	;forward HEAP_NEXT to the new node
               S04:000000AC:  30 28 FF FE
F00:0192       	move.w	d0,(HEAP_NEXT,a1)
               S04:000000B0:  33 40 FF FE
F00:0193       
F00:0194       	move.w	a1,(HEAP_NEXT,a0)
               S04:000000B4:  31 49 FF FE
F00:0195       
F00:0196       	move.w	a0,(HEAP_PREV,a1)
               S04:000000B8:  33 48 FF F8
F00:0197       
F00:0198       	tst.w	(HEAP_NEXT,a1)		;is there a next element?
               S04:000000BC:  4A 69 FF FE
F00:0199       	beq	.noNextElement		;no: then skip
               S04:000000C0:  67 0C
F00:0200       	move.w	a0,-(sp)		;we need to save a0, found block
               S04:000000C2:  3F 08
F00:0201       	move.w	(HEAP_NEXT,a1),a0	;get the next element
               S04:000000C4:  30 69 FF FE
F00:0202       	move.w	a1,(HEAP_PREV,a0)	;set the next.prev to the new block
               S04:000000C8:  31 49 FF F8
F00:0203       	move.w	(sp)+,a0		;restore a0
               S04:000000CC:  30 5F
F00:0204       .noNextElement:
F00:0205       
F00:0206       	move.w	#0,(HEAP_FREE,a1)	;mark this new block is free
               S04:000000CE:  33 7C 00 00 FF FA
F00:0207       	move.w	d1,(HEAP_SIZE,a1)	;save the size
               S04:000000D4:  33 41 FF FC
F00:0208       
F00:0209       .cantBreakDown:
F00:0210       	move.w	#-1,(HEAP_FREE,a0)	;yes: mark it as not free and return
               S04:000000D8:  31 7C FF FF FF FA
F00:0211       	move.l	a0,d0
               S04:000000DE:  20 08
F00:0212       	bra	.exit
               S04:000000E0:  60 0E
F00:0213       
F00:0214       .notUsable:
F00:0215       	tst.w	(HEAP_NEXT,a0)	;is there a next element?
               S04:000000E2:  4A 68 FF FE
F00:0216       	beq 	.fail		;no: no free space left to look through
               S04:000000E6:  67 06
F00:0217       	move.w	(HEAP_NEXT,a0),a0	;yes: set as next and loop
               S04:000000E8:  30 68 FF FE
F00:0218       	bra	.loop
               S04:000000EC:  60 90
F00:0219       
F00:0220       .fail:	moveq	#0,d0
               S04:000000EE:  70 00
F00:0221       .exit:	unlk	a5
               S04:000000F0:  4E 5D
F00:0222       	move.l	(sp),(4,sp)	;deallocate parameters
               S04:000000F2:  2F 57 00 04
F00:0223       	lea	(4,sp),sp
               S04:000000F6:  58 8F
F00:0224       	rts
               S04:000000F8:  4E 75
F00:0225       
F00:0226       ;---------------------------------------
F00:0227       ;advances the program break and returns
F00:0228       ;the new area of memory allocated
F00:0229       ;
F00:0230       ;	pea 	size
F00:0231       ;	pea 	last
F00:0232       ;	bsr 	requestSpace
F00:0233       ;---------------------------------------
F00:0234       ;a0 = newBlock
F00:0235       ;a1 = last
F00:0236       requestSpace:
F00:0237       	link	a5,#0
               S04:000000FA:  4E 55 00 00
F00:0238       
F00:0239       ;get the current program break
F00:0240       	pea 	0
               S04:000000FE:  48 78 00 00
F00:0241       	bsr 	sbrk
               S04:00000102:  61 00 FF 32
F00:0242       	move.l 	d0,a0
               S04:00000106:  20 40
F00:0243       
F00:0244       ;get the prev element for later
F00:0245       	move.l 	(8,a5),a1
               S04:00000108:  22 6D 00 08
F00:0246       
F00:0247       ;add the metta size to the request size and allocate space
F00:0248       	move.l	(12,a5),d0	;access params (size)
               S04:0000010C:  20 2D 00 0C
F00:0249       	addq.l 	#8,d0
               S04:00000110:  50 80
F00:0250       	move.l 	d0,-(sp)
               S04:00000112:  2F 00
F00:0251       	bsr 	sbrk
               S04:00000114:  61 00 FF 20
F00:0252       	cmpi.l 	#-1,d0		;did that fail?
               S04:00000118:  0C 80 FF FF FF FF
F00:0253       	beq	.fail 		;yes: return null (0)
               S04:0000011E:  67 28
F00:0254       
F00:0255       ;adjust pointer to where the data is for real
F00:0256       	addq.w	#8,a0
               S04:00000120:  50 48
F00:0257       
F00:0258       ;check if this block needs to be appended to a previous element
F00:0259       	cmpa.l 	#0,a1		;is there a prev (last) element?
               S04:00000122:  B2 FC 00 00
F00:0260       	beq	.noPrev		;no: skip this
               S04:00000126:  67 04
F00:0261       	move.w 	a0,(-2,a1)
               S04:00000128:  33 48 FF FE
F00:0262       .noPrev:
F00:0263       
F00:0264       	move.w	a1,(HEAP_PREV,a0)	;last
               S04:0000012C:  31 49 FF F8
F00:0265       	move.w	#-1,(HEAP_FREE,a0)	;free
               S04:00000130:  31 7C FF FF FF FA
F00:0266       	move.l 	(12,a5),d0
               S04:00000136:  20 2D 00 0C
F00:0267       	move.w	d0,(HEAP_SIZE,a0)	;size
               S04:0000013A:  31 40 FF FC
F00:0268       	move.w	#0,(HEAP_NEXT,a0)	;next
               S04:0000013E:  31 7C 00 00 FF FE
F00:0269       	move.l	a0,d0
               S04:00000144:  20 08
F00:0270       	bra 	.exit
               S04:00000146:  60 02
F00:0271       
F00:0272       
F00:0273       .fail:	moveq	#0,d0
               S04:00000148:  70 00
F00:0274       .exit:	unlk	a5
               S04:0000014A:  4E 5D
F00:0275       	move.l	(sp),(8,sp)	;deallocate parameters
               S04:0000014C:  2F 57 00 08
F00:0276       	lea	(8,sp),sp
               S04:00000150:  50 8F
F00:0277       	rts
               S04:00000152:  4E 75
F00:0278       
F00:0279       ;---------------------------------------
F00:0280       ;_malloc
F00:0281       ;
F00:0282       ;Allocates memory on the heap, returns
F00:0283       ;a pointer to memory or null (0)
F00:0284       ;
F00:0285       ;	pea	size
F00:0286       ;	bsr	_malloc
F00:0287       ;	addq.w 	#4,sp
F00:0288       ;---------------------------------------
F00:0289       	public	_malloc
F00:0290       _malloc:
F00:0291       	link	a5,#0
               S04:00000154:  4E 55 00 00
F00:0292       
F00:0293       ;allocating 0 bytes or -# bytes?
F00:0294       	tst.l	(8,a5)
               S04:00000158:  4A AD 00 08
F00:0295       	beq	.error
               S04:0000015C:  67 60
F00:0296       	blt	.error
               S04:0000015E:  6D 5E
F00:0297       
F00:0298       ;allocating an odd number of bytes?
F00:0299       	move.l	(8,a5),d0
               S04:00000160:  20 2D 00 08
F00:0300       	btst	#0,d0
               S04:00000164:  08 00 00 00
F00:0301       	beq	.even
               S04:00000168:  67 04
F00:0302       	addq.l	#1,(8,a5)	;make even to avoid address errors
               S04:0000016A:  52 AD 00 08
F00:0303       .even:
F00:0304       
F00:0305       ;1st time calling _malloc?
F00:0306       	tst.l	globalBase
               S04:0000016E:  4A B9 00 00 00 04 [R]
F00:0307       	bne	.notFirstTime
               S04:00000174:  66 1A
F00:0308       
F00:0309       ;yes: pass null as last, size as size, and call requestSpace
F00:0310       	move.l	(8,a5),d0
               S04:00000176:  20 2D 00 08
F00:0311       	move.l	d0,-(sp)
               S04:0000017A:  2F 00
F00:0312       	pea	0
               S04:0000017C:  48 78 00 00
F00:0313       	bsr	requestSpace
               S04:00000180:  61 00 FF 78
F00:0314       	tst.l	d0		;did that work?
               S04:00000184:  4A 80
F00:0315       	beq	.error		;no: return null (0)
               S04:00000186:  67 36
F00:0316       	move.l	d0,globalBase	;yes: set this as the start of the heap
               S04:00000188:  23 C0 00 00 00 04 [R]
F00:0317       	bra	.exit		;and exit
               S04:0000018E:  60 38
F00:0318       .notFirstTime:
F00:0319       
F00:0320       ;no: find a free block of memory first in the heap before allocating more memory
F00:0321       	move.l	(8,a5),-(sp)	;how many bytes?
               S04:00000190:  2F 2D 00 08
F00:0322       	bsr	findFreeBlock	;find it
               S04:00000194:  61 00 FE DA
F00:0323       	tst.l	d0		;did we find any?
               S04:00000198:  4A 80
F00:0324       	bne	.exit		;yes: we can exit
               S04:0000019A:  66 2C
F00:0325       	move.l	(8,a5),-(sp)	;no: we then allocate space
               S04:0000019C:  2F 2D 00 08
F00:0326       
F00:0327       ;find the end of the linked list
F00:0328       	move.l	globalBase,a0	;start at the beginning
               S04:000001A0:  20 79 00 00 00 04 [R]
F00:0329       .loop:	tst.w	(HEAP_NEXT,a0)	;is this->next == null?
               S04:000001A6:  4A 68 FF FE
F00:0330       	beq	.foundEnd	;yes: continue
               S04:000001AA:  67 06
F00:0331       	move.w	(HEAP_NEXT,a0),a0	;no: move onto the next element
               S04:000001AC:  30 68 FF FE
F00:0332       	bra	.loop		;and go back to the beginning
               S04:000001B0:  60 F4
F00:0333       .foundEnd:
F00:0334       	move.l	a0,-(sp)	;push the end of the linked list
               S04:000001B2:  2F 08
F00:0335       	bsr	requestSpace	;and allocate more memory on the heap
               S04:000001B4:  61 00 FF 44
F00:0336       
F00:0337       	tst.l	d0		;did that work?
               S04:000001B8:  4A 80
F00:0338       	beq	.error		;no: return null (0)
               S04:000001BA:  67 02
F00:0339       	bra	.exit		;and exit
               S04:000001BC:  60 0A
F00:0340       .error:	moveq	#0,d0			;if we had a problem, return null (0)
               S04:000001BE:  70 00
F00:0341       	move.b 	#ERROR_ENOMEM,_errno	;and set _errno
               S04:000001C0:  13 FC 00 07 00 00 00 00 [R]
F00:0342       .exit:	unlk	a5
               S04:000001C8:  4E 5D
F00:0343       	rts
               S04:000001CA:  4E 75
F00:0344       
F00:0345       ;---------------------------------------
F00:0346       ;_free
F00:0347       ;
F00:0348       ;free a pices of Memory
F00:0349       ;
F00:0350       ;	pea	ptr
F00:0351       ;	bsr	_free
F00:0352       ;	addq.w 	#4,sp
F00:0353       ;---------------------------------------
F00:0354       ;a0 = this
F00:0355       
F00:0356       	public	_free
F00:0357       _free:	link	a5,#0
               S04:000001CC:  4E 55 00 00
F00:0358       	move.l	a2,-(sp)	;we use a2
               S04:000001D0:  2F 0A
F00:0359       	move.l	(8,a5),a0	;get params
               S04:000001D2:  20 6D 00 08
F00:0360       	move.l	a0,a1		;get the full pointers populated
               S04:000001D6:  22 48
F00:0361       	move.l	a1,a2
               S04:000001D8:  24 49
F00:0362       
F00:0363       ;free this block of memory
F00:0364       	move.w	#0,(HEAP_FREE,a0)
               S04:000001DA:  31 7C 00 00 FF FA
F00:0365       
F00:0366       	move.w	(HEAP_NEXT,a0),a1
               S04:000001E0:  32 68 FF FE
F00:0367       	cmp.w	#0,a1
               S04:000001E4:  B2 FC 00 00
F00:0368       	beq	.nextNotFree	;no Next element
               S04:000001E8:  67 22
F00:0369       	tst.w	(HEAP_FREE,a1)	;is the next block free?
               S04:000001EA:  4A 69 FF FA
F00:0370       	bne 	.nextNotFree	;no: skip, see of prev is free
               S04:000001EE:  66 1C
F00:0371       	move.w	(HEAP_NEXT,a1),a2	;yes: concatinate the 2 blocks into 1
               S04:000001F0:  34 69 FF FE
F00:0372       	tst.w	(a2)		;unless there is no next element
               S04:000001F4:  4A 52
F00:0373       	beq 	.nextNotFree
               S04:000001F6:  67 14
F00:0374       
F00:0375       	move.w	a0,(HEAP_PREV,a2)	;set the next.next block to this block
               S04:000001F8:  35 48 FF F8
F00:0376       	move.w	a2,(HEAP_NEXT,a0)	;set this block to next.next
               S04:000001FC:  31 4A FF FE
F00:0377       	move.w	(HEAP_SIZE,a1),d0	;combine the size
               S04:00000200:  30 29 FF FC
F00:0378       	add.w	d0,(HEAP_SIZE,a0)
               S04:00000204:  D1 68 FF FC
F00:0379       	addq.w	#8,(HEAP_SIZE,a0)	;don't forget metta size
               S04:00000208:  50 68 FF FC
F00:0380       
F00:0381       .nextNotFree:
F00:0382       	move.w	(HEAP_PREV,a0),a1
               S04:0000020C:  32 68 FF F8
F00:0383       	cmp.w	#0,a1
               S04:00000210:  B2 FC 00 00
F00:0384       	beq	.prevNotFree	;no previous element
               S04:00000214:  67 26
F00:0385       	tst.w	(HEAP_FREE,a1)	;is the previous block free?
               S04:00000216:  4A 69 FF FA
F00:0386       	bne	.prevNotFree	;no: nothing else to do so exit
               S04:0000021A:  66 20
F00:0387       	move.w	(HEAP_PREV,a1),a2
               S04:0000021C:  34 69 FF F8
F00:0388       	tst.w	(a2)		;unless there is no prev block
               S04:00000220:  4A 52
F00:0389       	beq 	.prevNotFree
               S04:00000222:  67 18
F00:0390       
F00:0391       	move.w	(HEAP_NEXT,a0),a2
               S04:00000224:  34 68 FF FE
F00:0392       
F00:0393       	move.w	a1,(HEAP_PREV,a2)	;set the prev.next block to this block
               S04:00000228:  35 49 FF F8
F00:0394       	move.w	a2,(HEAP_NEXT,a1)	;set this block to next.next
               S04:0000022C:  33 4A FF FE
F00:0395       	move.w	(HEAP_SIZE,a0),d0	;combine the size
               S04:00000230:  30 28 FF FC
F00:0396       	add.w	d0,(HEAP_SIZE,a1)
               S04:00000234:  D1 69 FF FC
F00:0397       	addq.w	#8,(HEAP_SIZE,a1)	;don't forget metta size
               S04:00000238:  50 69 FF FC
F00:0398       
F00:0399       .prevNotFree:
F00:0400       	move.l	(sp)+,a2	;restore a2
               S04:0000023C:  24 5F
F00:0401       	unlk	a5
               S04:0000023E:  4E 5D
F00:0402       	rts
               S04:00000240:  4E 75
F00:0403       
F00:0404       ;---------------------------------------
F00:0405       ;initHeap
F00:0406       ;
F00:0407       ;Sets up the heap, should be called once
F00:0408       ;
F00:0409       ;	bsr	initHeap
F00:0410       ;---------------------------------------
F00:0411       	public	initHeap
F00:0412       initHeap:
F00:0413       	move.l	#0,globalBase
               S04:00000242:  23 FC 00 00 00 00 00 00 00 04 [R]
F00:0414       	pea 	heap
               S04:0000024C:  48 79 00 00 00 00 [R]
F00:0415       	bsr 	brk
               S04:00000252:  61 00 FD AC
F00:0416       	rts
               S04:00000256:  4E 75
F00:0417       
F00:0418       ;---------------------------------------
F00:0419       ;_calloc
F00:0420       ;
F00:0421       ;Description:
F00:0422       ;allocates n units of size size,
F00:0423       ;all set to 0.
F00:0424       ;
F00:0425       ;Calling Convention:
F00:0426       ;
F00:0427       ;void*	calloc(uint8_t n, uint16_t size);
F00:0428       ;
F00:0429       ;	pea	size
F00:0430       ;	pea	n
F00:0431       ;	bsr	_calloc
F00:0432       ;	addq.w	#8,sp
F00:0433       ;
F00:0434       ;RETUNRS:
F00:0435       ;a pointer to 0 init memory or null.
F00:0436       ;---------------------------------------
F00:0437       	public	_calloc
F00:0438       _calloc:
F00:0439       	link	a5,#0
               S04:00000258:  4E 55 00 00
F00:0440       	move.l	d2,-(sp)
               S04:0000025C:  2F 02
F00:0441       
F00:0442       	move.l	(8,a5),d0	;n
               S04:0000025E:  20 2D 00 08
F00:0443       	move.l	(12,a5),d1	;size
               S04:00000262:  22 2D 00 0C
F00:0444       	mulu	d0,d1		;d1 = final size
               S04:00000266:  C2 C0
F00:0445       	tst.l	d1		;final size = 0?
               S04:00000268:  4A 81
F00:0446       	bne	.validSize	;no: continue
               S04:0000026A:  66 04
F00:0447       	moveq	#0,d0		;yes: return null
               S04:0000026C:  70 00
F00:0448       	bra	.exit
               S04:0000026E:  60 20
F00:0449       .validSize:
F00:0450       	move.l	d1,-(sp)	;take our total size
               S04:00000270:  2F 01
F00:0451       	bsr	_malloc		;and do a regulat malloc call
               S04:00000272:  61 00 FE E0
F00:0452       	move.l	(sp)+,d1	;restore the size back to d1
               S04:00000276:  22 1F
F00:0453       	tst.l	d0		;did that work?
               S04:00000278:  4A 80
F00:0454       	beq	.exit		;no: return null
               S04:0000027A:  67 14
F00:0455       	move.l	d0,d2		;yes: save the pointer for now
               S04:0000027C:  24 00
F00:0456       	move.l	d0,-(sp)	;target
               S04:0000027E:  2F 00
F00:0457       	pea	0		;value
               S04:00000280:  48 78 00 00
F00:0458       	move.l	d1,-(sp)	;size
               S04:00000284:  2F 01
F00:0459       	bsr	_memset		;preform clearing
               S04:00000286:  61 00 00 00 [R]
F00:0460       	add.w	#12,sp		;clean op our mess
               S04:0000028A:  4F EF 00 0C
F00:0461       	move.l	d2,d0		;restore pointer to memory
               S04:0000028E:  20 02
F00:0462       .exit:	move.l	(sp)+,d2
               S04:00000290:  24 1F
F00:0463       	unlk	a5
               S04:00000292:  4E 5D
F00:0464       	rts
               S04:00000294:  4E 75
F00:0465       
F00:0466       ;---------------------------------------
F00:0467       ;_realloc
F00:0468       ;
F00:0469       ;used to dynamically change the memory
F00:0470       ;allocation of a previously allocated
F00:0471       ;memory.
F00:0472       ;
F00:0473       ;Calling Convention
F00:0474       ;void*   realloc(void* ptr, uint16_t size);
F00:0475       ;
F00:0476       ;	move.l	#size,-(sp)
F00:0477       ;	pea	ptr
F00:0478       ;	bsr	_realloc
F00:0479       ;	addq	#8,sp
F00:0480       ;
F00:0481       ;---------------------------------------
F00:0482       ;d0 =
F00:0483       ;d1 =
F00:0484       ;d2 = pointer to new block
F00:0485       ;d3 = pointer to original block
F00:0486       ;d4 = size
F00:0487       	public	_realloc
F00:0488       _realloc:
F00:0489       	link	a5,#0
               S04:00000296:  4E 55 00 00
F00:0490       	move.l	d2,-(sp)
               S04:0000029A:  2F 02
F00:0491       	move.l	d3,-(sp)
               S04:0000029C:  2F 03
F00:0492       	move.l	d4,-(sp)
               S04:0000029E:  2F 04
F00:0493       
F00:0494       	move.l	(8,a5),d3	;pointer
               S04:000002A0:  26 2D 00 08
F00:0495       	move.l	(12,a5),d4	;size
               S04:000002A4:  28 2D 00 0C
F00:0496       
F00:0497       ;allocate new block of memory
F00:0498       	move.l	d4,-(sp)	;size
               S04:000002A8:  2F 04
F00:0499       	bsr	_malloc		;allocate it
               S04:000002AA:  61 00 FE A8
F00:0500       	move.l	d0,d2		;save the result
               S04:000002AE:  24 00
F00:0501       	tst.l	d2		;any problems?
               S04:000002B0:  4A 82
F00:0502       	beq	.exit		;yes: return null
               S04:000002B2:  67 0E
F00:0503       
F00:0504       ;copy stuff over
F00:0505       	move.l	d4,-(sp)	;size
               S04:000002B4:  2F 04
F00:0506       	move.l	d3,-(sp)	;src
               S04:000002B6:  2F 03
F00:0507       	move.l	d2,-(sp)	;dest
               S04:000002B8:  2F 02
F00:0508       	bsr	_memcpy
               S04:000002BA:  61 00 00 00 [R]
F00:0509       	add.w	#12,sp
               S04:000002BE:  4F EF 00 0C
F00:0510       
F00:0511       ;clean up our mess
F00:0512       .exit:	move.l	d3,-(sp)	;free the original pointer
               S04:000002C2:  2F 03
F00:0513       	bsr	_free
               S04:000002C4:  61 00 FF 06
F00:0514       	addq.w	#4,sp
               S04:000002C8:  58 4F
F00:0515       	move.l	d2,d0		;store result
               S04:000002CA:  20 02
F00:0516       	move.l	(sp)+,d4
               S04:000002CC:  28 1F
F00:0517       	move.l	(sp)+,d3
               S04:000002CE:  26 1F
F00:0518       	move.l	(sp)+,d2
               S04:000002D0:  24 1F
F00:0519       	unlk	a5
               S04:000002D2:  4E 5D
F00:0520       	rts
               S04:000002D4:  4E 75
F00:0521       


Sections:
S01  BSS
S02  HEAP
S03  DATA
S04  CODE


Sources:
F00  DynamicMemory.asm
F01  errno.inc


Symbols:
_memcpy IMP REF 
 _realloc .exit LAB (0x2c2) sec=CODE 
_realloc LAB (0x296) UNUSED EXPORT sec=CODE 
_memset IMP REF 
 _calloc .exit LAB (0x290) sec=CODE 
 _calloc .validSize LAB (0x270) sec=CODE 
_calloc LAB (0x258) UNUSED EXPORT sec=CODE 
initHeap LAB (0x242) UNUSED EXPORT sec=CODE 
 _free .prevNotFree LAB (0x23c) sec=CODE 
 _free .nextNotFree LAB (0x20c) sec=CODE 
_free LAB (0x1cc) EXPORT sec=CODE 
 _malloc .foundEnd LAB (0x1b2) sec=CODE 
 _malloc .loop LAB (0x1a6) sec=CODE 
 _malloc .exit LAB (0x1c8) sec=CODE 
 _malloc .notFirstTime LAB (0x190) sec=CODE 
 _malloc .even LAB (0x16e) sec=CODE 
 _malloc .error LAB (0x1be) sec=CODE 
_malloc LAB (0x154) EXPORT sec=CODE 
 requestSpace .exit LAB (0x14a) sec=CODE 
 requestSpace .noPrev LAB (0x12c) sec=CODE 
 requestSpace .fail LAB (0x148) sec=CODE 
requestSpace LAB (0xfa) sec=CODE 
 findFreeBlock .fail LAB (0xee) sec=CODE 
 findFreeBlock .exit LAB (0xf0) sec=CODE 
 findFreeBlock .noNextElement LAB (0xce) sec=CODE 
 findFreeBlock .cantBreakDown LAB (0xd8) sec=CODE 
 findFreeBlock .notUsable LAB (0xe2) sec=CODE 
 findFreeBlock .loop LAB (0x7e) sec=CODE 
findFreeBlock LAB (0x70) sec=CODE 
 sbrk .exit LAB (0x66) sec=CODE 
 sbrk .error LAB (0x5c) sec=CODE 
sbrk LAB (0x36) sec=CODE 
_errno IMP REF 
 brk .exit LAB (0x2c) sec=CODE 
 brk .error LAB (0x22) sec=CODE 
brk LAB (0x0) sec=CODE 
heap LAB (0x0) REF sec=HEAP 
globalBase LAB (0x4) REF sec=BSS 
programBreak LAB (0x0) REF sec=BSS 
HEAP_NEXT EXPR(-2=0xfffffffe) EQU 
HEAP_SIZE EXPR(-4=0xfffffffc) EQU 
HEAP_FREE EXPR(-6=0xfffffffa) EQU 
HEAP_PREV EXPR(-8=0xfffffff8) EQU 
HEAP_SIZE_TOTAL EXPR(24575=0x5fff) EQU 
ERROR_ENOMEM EXPR(7=0x7) EQU 
ERROR_NONE EXPR(0=0x0) UNUSED EQU 
UNKNOWN_INPUT EXPR(9=0x9) UNUSED EQU 
OUT_OF_BOUNDS EXPR(8=0x8) UNUSED EQU 
OUT_OF_MEMORY EXPR(7=0x7) EQU 
TOO_LONG EXPR(6=0x6) UNUSED EQU 
DEADLOCK EXPR(5=0x5) UNUSED EQU 
IO_ERROR EXPR(4=0x4) UNUSED EQU 
BAD_ADDRESS EXPR(3=0x3) UNUSED EQU 
DOES_NOT_EXIST EXPR(2=0x2) UNUSED EQU 
FILE_NOT_FOUND EXPR(1=0x1) UNUSED EQU 
NONE EXPR(0=0x0) EQU 
_MOVEMBYTES EXPR(0=0x0) INTERNAL 
 MOVEMSIZE EXPR(0=0x0) INTERNAL 
_MOVEMREGS EXPR(0=0x0) INTERNAL 
__LINE__ EXPR(521=0x209) INTERNAL 
__FO EXPR(0=0x0) INTERNAL 
__RS EXPR(0=0x0) INTERNAL 
REPTN EXPR(-1=0xffffffff) INTERNAL 
__VASM EXPR(1=0x1) INTERNAL 
__UNIXFS EXPR(0=0x0) INTERNAL 

There have been no errors.
